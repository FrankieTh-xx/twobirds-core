<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/tb/tb.js - twoBirds</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="twoBirds" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v7.1.7</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/tb.html">tb</a></li>
                                <li><a href="../classes/tb.dom.html">tb.dom</a></li>
                                <li><a href="../classes/tb.Event.html">tb.Event</a></li>
                                <li><a href="../classes/tb.Model.html">tb.Model</a></li>
                                <li><a href="../classes/tb.Require.html">tb.Require</a></li>
                                <li><a href="../classes/tb.Selector.html">tb.Selector</a></li>
                                <li><a href="../classes/tb.Util.html">tb.Util</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/tb/tb.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! twobirds-core - v7.1.7 - 2016-07-10 */

/**
 twoBirds V7 core functionality

 @author          frank.thuerigen &lt;frank_thuerigen@yahoo.de&gt;
 @copyright       copyright (c) 2006- Frank Th√ºrigen
 @license         http://www.gnu.org/copyleft/gpl.html GNU GPL v3

 */

// POLYFILLS

// matches polyfill
this.Element &amp;&amp; function(ElementPrototype) {
    ElementPrototype.matches = ElementPrototype.matches ||
        ElementPrototype.matchesSelector ||
        ElementPrototype.webkitMatchesSelector ||
        ElementPrototype.msMatchesSelector ||
        function(selector) {
            var node = this,
                nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;
            while (nodes[++i] &amp;&amp; nodes[i] != node);
            return !!nodes[i];
        }
}(Element.prototype);

// closest polyfill
this.Element &amp;&amp; function(ElementPrototype) {
    ElementPrototype.closest = ElementPrototype.closest ||
        function(selector) {
            var el = this;
            while (el.matches &amp;&amp; !el.matches(selector)) el = el.parentNode;
            return el.matches ? el : null;
        }
}(Element.prototype);

// twoBirds

tb = (function(){

    /**
     @class tb.Selector
     @constructor
     @extends tb

     @param {function|string|object|array} pSelector

     @returns {object} - the twoBirds instance you just created

     twoBirds selector constructor

     CAUTION: you may use this class directly if you know what you are doing,
     but the correct syntax for call is simply:

     @example

         tb( pSelector )
            .whateverChainedMethod(); // etc.

     HINT: tb() works as a selector, new tb() instanciates a twoBirds instance from a class.

     @example

         // get tB instances from DOM by css query selector
         tb( &#x27;div&#x27; )            // any tbInstance that sits in a div dom node

         // get tB instances from DOM by constructor
         tb( app.sampleConstructor )     // any tbInstance in DOM that is instanceof sampleConstructor

         // get tB instances from DOM by regEx
         tb( /myRegEx/ )    // any tbInstance in DOM that has a namespace property that fits the regEx

         // get tB instances from DOM by array of selectors
         tb( [ &#x27;body&#x27;, /myRegEx/ ] )     // any combination of selectors in an array, result is additive, flat and unique

     */
    function TbSelector( pSelector ){
        var that = this;

        that.length = 0;

        if ( !pSelector ) return that;

        switch (typeof pSelector) {

            // selection by dom selector string
            case &#x27;string&#x27;:
                // HINT: must be a tb element for every selector of a css selector string
                var selector = pSelector.split(&#x27; &#x27;),
                    selector = selector.map(function(s){
                        if (1 &lt; s.length){
                            return s+&#x27;:not([data-tb=&quot;&quot;])&#x27;;
                        }
                        return s;
                    }),
                    selector = selector.join(&#x27; &#x27;);

                tb.dom( selector )
                    .forEach(
                        function ( pDomNode ) {
                            pDomNode.tb
                                .forEach(
                                    function( pTbElement ){
                                        [].push.call( that, pTbElement ); // push dom object to tb selector content
                                    }
                                )
                        }
                    );
                break;

            case &#x27;object&#x27;:  // either regEx or nodeType

                if ( pSelector instanceof tb ){ // it is a twoBirds object

                    [].push.call( that, pSelector );
                    return that;

                }

                if ( pSelector instanceof RegExp ){ // it is a regular expression

                    tb.dom( &#x27;[data-tb]&#x27; )
                        .forEach(
                            function ( pDomNode ) {
                                pDomNode.tb
                                    .forEach(
                                        function( pTbElement ){
                                            if ( pTbElement instanceof tb
                                                &amp;&amp; !!pTbElement[&#x27;namespace&#x27;]
                                                &amp;&amp; !!pTbElement.namespace.match(pSelector)
                                            ){
                                                [].push.call( that, pTbElement );
                                            }
                                        }
                                    )
                            }
                        );

                } else if ( !!pSelector[&#x27;nodeType&#x27;] &amp;&amp; !!pSelector[&#x27;tb&#x27;] ){ // it is a dom node containing tb elements
                        pSelector.tb
                            .forEach(
                                function( pTbElement ){
                                    [].push.call( that, pTbElement );
                                }
                            )

                } else if ( pSelector.constructor === Array || !!pSelector[&#x27;length&#x27;] &amp;&amp; !!pSelector[&#x27;0&#x27;] &amp;&amp; !(pSelector instanceof Array) ){
                    // it is an array || array like object
                    [].forEach.call(
                        pSelector,
                        function( pThisSelector ){
                            var thisResult = tb( pThisSelector );
                            [].forEach.call(
                                thisResult,
                                function( pTbElement ){
                                    if ( -1 === [].indexOf.call( that, pTbElement ) ){
                                        [].push.call( that, pTbElement );
                                    }
                                }
                            );
                        }
                    );
                }

                break;

            // selection by constructor: get all tb instances from DOM,
            // check whether their prototype matches constructor prototype
            case &#x27;function&#x27;:

                tb.dom( &#x27;[data-tb]&#x27; )
                    .map(
                        function ( pDomNode ) {
                            pDomNode.tb
                                .forEach(
                                    function( pTbElement ){
                                        if ( pTbElement instanceof tb
                                            &amp;&amp; pTbElement instanceof pSelector
                                        ){
                                            [].push.call( that, pTbElement );
                                        }
                                    }
                                )
                        }
                    );

                break;
        }

        return that;

    }

    // empty class def for temporary handler storage, needed for on(), one(), off() and trigger()
    function Nop(){};
    Nop.prototype = { namespace: &#x27;Nop&#x27; };

    // HINT: TbSelector (class) prototype definition after Tb prototype definition

    /**
     @class tb
     @constructor

     @param {object} pOptions
     @param pOptions.pClass - class Namespace as string or class
     @param [pOptions.pConfig] - optional configuration, any type, preferrably object
     @param [pOptions.pTarget] - target to put object in, DOM node or any other object

     @returns {object} - the twoBirds instance you just created

     twoBirds constructor

     @example

         // put Instance into DOM node
         new tb(
             app.myConstructor,                                     // any constructor you want to have an instance of
             { ... },                                               // the config object you hand over to the constructor
             target.appendChild( document.createElement( &#x27;span&#x27; ) ) // DOM node to insert the object item
         );

         // put Instance anywhere
         new tb(
             app.myConstructor,            // any constructor you want to have an instance of
             { ... },                      // the config object you hand over to the constructor
             anotherTbInstance             // any other object you want to put the tb instance in
         );

         // if a namespace STRING is given, requirement loading is done in case the class isnt present yet
         new tb(
             &#x27;app.myConstructor&#x27;,          // namespace string for the constructor you want to have an instance of
             { ... },                      // the config object you hand over to the constructor
             anotherTbInstance             // any other object you want to put the tb instance in
         );

     */
    function tb() {
        var that = this;

        // setup prototype chain of twoBirds instance
        function makePrototype( pPrototype ){

            // make custom class constructor
            var f = function ( pPrototype ){

                var that = this;

                for ( var i in pPrototype ) if ( pPrototype.hasOwnProperty(i) ){
                    that[i] = pPrototype[i];
                }

            };

            f.prototype = tb.prototype;

            return new f( pPrototype );
        }

        // merge handlers from temp instance into target object
        function mergeHandlers( pSourceTb , pTargetTb ){
            for ( var i in pSourceTb.handlers ) if ( pSourceTb.handlers.hasOwnProperty(i) ){
                if ( !pTargetTb.handlers[i] ){
                    pTargetTb.handlers[i] = [];
                }
                for ( var j = 0, l = pSourceTb.handlers[i].length; j &lt; l; j++ ){
                    pTargetTb.handlers[i].push( pSourceTb.handlers[i][j] ); // copy handler
                }
            }
        }

        // instanciate tb instance OR return tb.Selector result set
        if ( that instanceof tb ) {    // called as constructor, create and return tb object instance
            var isNamespace = typeof arguments[0] === &#x27;string&#x27;,
                tbClass =  isNamespace ? tb.namespace( arguments[0] ) : arguments[0],
                tbInstance,
                fileName,
                tempInstance; // empty tb object, used as handler store

            // namespace is a string and corresponding class doesnt exist in repo
            // -&gt; do requirement loading
            // -&gt; return temporary instance ( = instanceof Nop )
            if ( isNamespace &amp;&amp; !tbClass ){
                fileName = arguments[0].replace( /\./g, &#x27;/&#x27; ) + &#x27;.js&#x27;;
                tempInstance = new tb( Nop, arguments[1] || {}, arguments[2] || false ); // construct temp tb instance from empty constructor -&gt; temp handler store

                tb.loader.load(
                    fileName,
                    (function( args ){
                        return function(){
                            var thisTb = new tb(
                                args[0],
                                args[1] || {},
                                args[2] || false
                            );

                            if ( !!tempInstance ){

                                // copy properties from tempInstance, always shallow copy
                                for ( var i in tempInstance ) if (
                                    ([&#x27;handlers&#x27;, &#x27;target&#x27;]).indexOf(i) === -1
                                    &amp;&amp; tempInstance.hasOwnProperty(i)
                                ){
                                    thisTb[i] = tempInstance[i];
                                }

                                mergeHandlers( tempInstance, thisTb );

                            }

                        };
                    })( [].slice.call( arguments ) )
                );

                return tempInstance; // return temp instance so handlers can be attached
            }

            // it is a constructor call, like &quot;new tb(...)&quot;
            if ( typeof tbClass === &#x27;function&#x27; ){

                // prepare
                if ( !tbClass.prototype.__tb__ ){
                    tbClass.prototype.__tb__ = &#x27;V7&#x27;;
                    tbClass.prototype = makePrototype( tbClass.prototype, tbClass );
                }

                // make a new instance of given constructor
                tbInstance = new tbClass( arguments[1] || {}, arguments[2] ); // hidden parameter target

                // prepare .namespace property of tb object
                if ( !tbInstance.namespace
                    &amp;&amp; !( tbInstance instanceof Nop )
                ){
                    tbInstance.namespace = typeof arguments[0] === &#x27;string&#x27;
                        ? arguments[0]
                        : arguments[0].namespace || tb.getId(); // if nothing helps, a unique id
                }

                // prepare .target property of tb object
                tbInstance.target = arguments[2] || false; // preset
                if ( !!arguments[2] ){
                    if ( !arguments[2][&#x27;nodeType&#x27;]
                        &amp;&amp; !!arguments[2][0]
                        &amp;&amp; !!arguments[2][0][&#x27;nodeType&#x27;]
                    ){
                        arguments[2] = arguments[2][0]; // get first element of an array-like selector return object
                    }

                    tbInstance.target = arguments[2];
                } else {
                    tbInstance.target = null;
                }

                // if target is a DOM element
                // - add class to DOM data
                // - if not already there add namespace to target data-tb attribute
                if ( tbInstance.target &amp;&amp; tbInstance.target.nodeType &amp;&amp; !( tbInstance instanceof Nop ) ){

                    // put tb instance in dom node
                    tbInstance.target.tb = !!tbInstance.target[&#x27;tb&#x27;] ? tbInstance.target.tb : [];
                    tbInstance.target.tb[tbInstance.namespace] = tbInstance;

                    // if element does not reside in the DOM &lt;head&gt; add class
                    var dom = tb.dom( tbInstance.target );

                    // add class
                    if ( tbInstance.target.nodeName !== &#x27;head&#x27;
                        &amp;&amp; dom.parents().toArray().indexOf( document.head ) === -1
                        &amp;&amp; !!tbInstance[&#x27;namespace&#x27;]
                    ){
                        dom.addClass( tbInstance.namespace.replace( /\./g, &#x27;-&#x27;).toLowerCase() );
                    }

                    // add namespace to DOM &quot;data-tb&quot; attribute
                    if ( !!tbInstance.target &amp;&amp; !!tbInstance.target[&#x27;nodeType&#x27;] ){
                        var dataTb = tbInstance.target.getAttribute( &#x27;data-tb&#x27; );
                        if ( !!dataTb &amp;&amp; !!dataTb.length &amp;&amp; -1 === dataTb.split(&#x27; &#x27;).indexOf( tbInstance.namespace ) ){
                            tbInstance.target.setAttribute( &#x27;data-tb&#x27;, dataTb + &#x27; &#x27; + tbInstance.namespace );
                        } else {
                            tbInstance.target.setAttribute( &#x27;data-tb&#x27;, tbInstance.namespace )
                        }
                    }
                }

                // create handlers array if necessary
                if ( !tbInstance[ &#x27;handlers&#x27; ] ){
                    tbInstance.handlers = {};
                } else {
                    // if there are single named event handler functions,
                    // convert them to array of functions
                    for ( var i in tbInstance.handlers ) if ( tbInstance.handlers.hasOwnProperty(i) ){
                        if ( typeof tbInstance.handlers[i] === &#x27;function&#x27; ){
                            tbInstance.handlers[i] = [ tbInstance.handlers[i] ];
                        } else if ( !( tbInstance.handlers[i] instanceof Array ) ){
                            delete tbInstance.handlers[i];
                        }
                    }
                }

                if ( !( tbInstance instanceof Nop ) ){
                    
                    // trigger init directly if no requirement array
                    if ( !tbInstance[&#x27;tb.Require&#x27;] ) {
                        tbInstance.trigger( &#x27;init&#x27; );
                    } // otherwise tb.require will trigger &#x27;init&#x27;

                    // add property declared classes (prop contains &quot;.&quot;) as tb objects
                    for ( var key in tbInstance ) {
                        if ( typeof key === &#x27;string&#x27;
                            &amp;&amp; key.indexOf( &#x27;.&#x27; ) &gt; -1
                        ){ // prop name contains &quot;.&quot;, treat as tb class
                            tbInstance[key] = new tb( key, tbInstance[key], tbInstance );
                        }
                    }

                }

                return tbInstance;

            }

        } else { // arguments[0] is string or regex, return selector result

            return new TbSelector( !!arguments[0] ? arguments[0] : undefined );

        }

    }

    tb.Selector = TbSelector; // make official, e.g. for events

    /**
      walk all pSelector tb objects, call pMethodName on them
      return a UNIQUE TbSelector result set containing all single results

      @function walkSelector
      @private

      @param {object} pSelectorObject - instanceOf TbSelector
      @param {string} pMethodName - name of method to call
      @param {*} [pArguments] - arguments

      @return {object} instance of TbSelector
     */
    function walkSelector( pSelectorObject, pMethodName, pArguments ){
        var that = this,
            result,
            ret = tb( &#x27;&#x27; ); // empty tb selector object

        if ( pSelectorObject instanceof TbSelector ) {
            [].forEach.call(
                [].map.call( pSelectorObject, function( pElement, pKey ){
                    if ( pSelectorObject.hasOwnProperty( pKey ) ){
                        return pSelectorObject[ pKey ];
                    }
                }),
                function walkSelectorEach( pTbObject, pKey ) {
                    result = pTbObject[pMethodName].apply( pTbObject, [].slice.call( pArguments ) );

                    [].forEach.call(
                        result,
                        function( pResultObject ){
                            if ( [].indexOf.call( ret, pResultObject ) === -1 ){
                                [].push.call( ret, pResultObject );
                            }
                        }
                    );
                }
            );
        }
        return ret;
    }

    tb.prototype = (function(){
        // private static

        function _toArray( pTbSelector ){
            if ( pTbSelector &amp;&amp; pTbSelector instanceof tb ){
                return [].map.call(
                    pTbSelector,
                    function ( pElement ){
                        return pElement;
                    }
                );
            }
            return [];
        }

        return {
            // public methods and properties

            /**
             @method set
             @chainable

             @param {string} [pKey] - name of the property
             @param [pValue] - any kind of value associated with the key

             @return {object} - tb.Selector instance or tB instance - for chaining

             set() method

             sets an instance property

             @example

                var a = new tb(...); // create a tB instance
                a.set( &#x27;x&#x27;: 42 );

             */
            set: function( pKey, pValue ){

                var that = this;

                if ( that instanceof TbSelector ) {

                    [].forEach.call(
                        that,
                        function( pElement ){
                            pElement.set( pKey, pValue );
                        }
                    );

                    return that;

                } else if ( that instanceof tb ){

                    that[pKey] = pValue;

                }

                return that;
            },

            /**
             @method get

             @param {string} [pKey] - name of the property

             @return any value stored in property, or undefined

             get() method

             get an instance property

             @example

                 var a = new tb(...); // create a tB instance
                 a.get( &#x27;x&#x27; );

             */
            get: function( pKey, undefined ){

                var that = this;

                if ( that instanceof TbSelector ) {

                    return that[0][ pKey ];

                } else if ( that instanceof tb ){

                    return that[ pKey ];

                }

                return undefined;
            },

            /**
              @method trigger
              @chainable

              @param {string} pEvent - name of event OR tb.Event instance (in this case the only parameter)
              @param [pEventData] - event data, usally an object
              @param {string} [pBubble=l] - bubbling indicator : &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down - or any combination

              @return {object} - tb.Selector instance or tB instance - for chaining

              trigger method

              triggers an asynchronous twoBirds event, optionally with data and bubble indicator

             */
            trigger: function( pEvent, pEventData, pBubble ){
                var that = this,
                    tbEvent;

                if( tb.stop() ){ // @todo rethink this
                    return;
                }

                // construct event if necessary
                tbEvent = pEvent instanceof tb.Event ? pEvent : new tb.Event( pEvent, pEventData, pBubble );

                // if event __stopped__ , handling is cancelled
                if ( tbEvent.__stopped__  ) {
                    return that;
                }

                // execute local handlers
                if ( that instanceof TbSelector &amp;&amp; !!that[&#x27;length&#x27;] ) {

                    [].forEach.call(
                        that,
                        function( tbInstance ){
                            if ( !!tbInstance
                                &amp;&amp; tbInstance instanceof tb
                                &amp;&amp; !tbEvent.__immediateStopped__
                            ){
                                tbInstance.trigger( tbEvent );
                            }
                        }
                    );

                } else if ( that instanceof tb ) { // it must be a native tb object

                    if ( that instanceof Nop
                        &amp;&amp; tbEvent.name !== &#x27;init&#x27;
                    ){
                        // its an object that was not loaded yet
                        that.one(
                            &#x27;init&#x27;,
                            function lazyHandler(){
                                var that = this;

                                that.trigger( tbEvent );
                            }
                        );
                        return that;
                    }

                    // local handlers
                    if ( !!that.handlers[tbEvent.name] &amp;&amp; tbEvent.bubble.indexOf( &#x27;l&#x27; ) &gt; -1 ) {

                        var temp = [];

                        that.handlers[tbEvent.name].map(
                            function (handler) {

                                if ( tbEvent.bubble.indexOf(&#x27;l&#x27;) &gt; -1
                                    &amp;&amp; !tbEvent.__immediateStopped__
                                    &amp;&amp; !!handler
                                ){
                                    setTimeout(
                                        function(){
                                            try{
                                                handler.apply(that, [tbEvent]);
                                            } catch (e){
                                                console.error(e);
                                            }
                                        }
                                        ,0
                                    );

                                    if ( !handler.once ) {
                                        temp.push( handler );
                                    }
                                }

                            }
                        );

                        that.handlers[tbEvent.name] = temp;

                    }

                    // if event __stopped__ , handling is cancelled
                    if ( !!tbEvent.__stopped__  ) {
                        return that;
                    }

                    setTimeout(
                        function(){

                            // bubble up
                            if ( tbEvent.bubble.indexOf(&#x27;u&#x27;) &gt; -1 ){
                                tbEvent.bubble += tbEvent.bubble.indexOf(&#x27;l&#x27;) === -1 ? &#x27;l&#x27; : &#x27;&#x27;;
                                var done = false,
                                    tbObject = that;

                                while ( !done &amp;&amp; !!tbObject ){
                                    var tbObject = tbObject.parent()[0] || false;

                                    if ( !!tbObject[&#x27;handlers&#x27;]
                                        &amp;&amp; !tbEvent.__stopped__
                                        &amp;&amp; tbObject.handlers[ tbEvent.name ]
                                    ){
                                        tbObject.trigger( tbEvent );
                                    }
                                }
                            }

                            // bubble down
                            if ( tbEvent.bubble.indexOf(&#x27;d&#x27;) &gt; -1 ){
                                tbEvent.bubble += tbEvent.bubble.indexOf(&#x27;l&#x27;) === -1 ? &#x27;l&#x27; : &#x27;&#x27;;
                                [].map.call(
                                    that.children(),
                                    function( tbObject ){
                                        if ( tbObject.handlers[ tbEvent.name ] ){
                                            tbObject.trigger(
                                                new tb.Event(
                                                    tbEvent.name,
                                                    tbEvent.data,
                                                    tbEvent.bubble
                                                )
                                            );
                                        }
                                    }
                                );
                            }

                        },
                        10
                    )

                }

                return that;

            },

            /**
             @method on
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array
             @param {boolean} [pOnce=false] - true = remove handler after first call, false = keep handler

             @return {object} - tb.Selector instance or tB instance - for chaining

             .on() method

             adds a handler to a twoBirds instance or a tb.Selector result set
             */
            on: function( pEventName, pHandler, pOnce ){

                var that = this,
                    eventNames;

                if ( -1 &lt; pEventName.indexOf(&#x27; &#x27;) ){
                    eventNames = pEventName.split(&#x27; &#x27;);
                } else {
                    eventNames = [ pEventName ];
                }
                pHandler.once = !!pHandler.once || !!pOnce;

                eventNames.forEach(function(pEventName){
                    if ( that instanceof TbSelector ) {

                        walkSelector( that, &#x27;on&#x27;, arguments );

                    } else if ( that instanceof tb) {

                        if ( !that.handlers ){
                            that.handlers = {};
                        }

                        if ( !that.handlers[ pEventName ] ){
                            that.handlers[ pEventName ] = [];
                        }

                        that.handlers[ pEventName ].push( pHandler );
                    }
                });

                return that;

            },

            /**
             @method one
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array

             @return {object} - tb.Selector instance or tB instance - for chaining

             .one() method

             adds a handler to a twoBirds instance or a tb.Selector result set,
             to be called only once when the event fires
             afterwards the handler is deleted from the event handler list
             */
            one: function( pEventName, pHandler ){

                var that = this;

                that.on( pEventName, pHandler, true ); // add event that is only being triggered once

                return that;

            },

            /**
             @method off
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array

             @return {object} - tb.Selector instance or tB instance - for chaining

             .off() method

             removes a handler from a twoBirds instance or a tb.Selector result set
             afterwards the handler is deleted from the event handler list
             */
            off: function( pEventName, pHandler ){

                var that = this,
                    index,
                    eventNames;

                if ( -1 &lt; pEventName.indexOf(&#x27; &#x27;) ){
                    eventNames = pEventName.split(&#x27; &#x27;);
                } else {
                    eventNames = [ pEventName ];
                }
                pHandler.once = !!pHandler.once || !!pOnce;

                eventNames.forEach(function(pEventName){
                    if ( that instanceof TbSelector ) {

                        walkSelector( that, &#x27;off&#x27;, arguments );

                    } else if ( that instanceof tb ) { // either a toplevel or an internal tb object

                        if ( !that.handlers[ pEventName ] ){
                            return;
                        }

                        index = that.handlers[ pEventName].indexOf( pHandler );

                        if ( index &gt; -1 ){
                            that.handlers[ pEventName ].splice( index, 1 );
                        }

                    }
                });

                return that;

            },

            /**
             @method parents
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .parents() method

             for each this[0...n] or this as tb() instance,
             - get all parent tb objects
             - check them against the filter param pSelector
             - return them as a TbSelector result set (unique)
             */
            parents: function( pSelector ){
                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parents&#x27;, arguments );

                } else if ( that instanceof tb
                    &amp;&amp; !!that.target
                ){ // it is a tb object

                    if ( !!that.target[&#x27;nodeType&#x27;] ){
                        // it must be a native toplevel tb object residing in the DOM
                        tb.dom( that.target )
                            .parents( &#x27;[data-tb]&#x27; )
                            .not( &#x27;html&#x27; )
                            .toArray()
                            .forEach(
                                function( pElement ){
                                    Object
                                        .keys( pElement.tb )
                                        .forEach(
                                            function( pKey ){
                                                // push dom object to tb selector content
                                                [].push.call( ret, pElement.tb[pKey] );
                                            }
                                        )
                                }
                            );

                    } else if ( that.target instanceof tb ){
                        // it a tb object embedded in another tb object

                        [].push.call( ret, that.target ); // push parent object to tb selector content

                        if ( !!that.target.parent()[&#x27;0&#x27;] ){
                            [].push.call( ret, that.target.parent()[&#x27;0&#x27;] )
                        }

                    }


                }

                return pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method parent
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .parent() method

             for each this[0...n] or this as tb() instance,
             - get closest parent tb object
             - check all of them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            parent: function( pSelector ){

                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parent&#x27;, arguments );

                } else if ( that instanceof tb
                    &amp;&amp; !!that.target
                ){

                    if ( !!that.target[&#x27;nodeType&#x27;] ) { // tb object resides in DOM

                        var tbParents = that.parents().toArray(),
                            tbParent = !!tbParents[&#x27;0&#x27;] ? tbParents[0] : false;

                        if ( !tbParent ) return ret; // no parent -&gt; empty result set

                        tbParent.target.tb
                            .forEach(function( tbElement ){
                                [].push.call( ret, tbElement ); // push dom object to tb selector content
                            });

                    } else if ( that.target instanceof tb ){ // it is an embedded object, local target is another (parent) tb object

                        [].push.call( ret, that.target ); // push parent object to tb selector content

                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method descendants
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .descendants() method

             for each this[0...n] or this as tb() instance,
             - get all descendants of tb object
             - check them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            descendants: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;descendants&#x27;, arguments );

                } else if ( that instanceof tb &amp;&amp; !!that.target[&#x27;nodeType&#x27;] &amp;&amp; !pLocalOnly ) { // it must be a native tb object

                    tb.dom( &#x27;[data-tb]&#x27;, that.target )
                        .forEach(
                            function( pDomElement ) {
                                pDomElement.tb
                                    .forEach(function( tbElement ){
                                        [].push.call( ret, tbElement ); // push dom object to tb selector content
                                    });
                            }
                        );

                } else if ( that instanceof tb &amp;&amp; !!pLocalOnly ){ // walk descendants
                    // HINT: if tbInstances are stacked inside each other, only props in &quot;this&quot; will be copied
                    //       ...not those defined in the constructor.prototype ( like &#x27;tb.Require&#x27; )
                    Object
                        .keys( that )
                        .forEach(function( pKey ){
                            if ( pKey !== &#x27;target&#x27; &amp;&amp; that[pKey] instanceof tb ) {
                                [].push.call( ret, that[pKey]); // push tb object to tb selector content

                                var desc = tb.dom().toArray.call( that[pKey].descendants( &#x27;&#x27;, true ) );

                                for ( var j=0, l=desc.length; j&lt;l; j++ ){
                                    [].push.call( ret, desc[j]); // push tb object to tb selector content
                                }
                            }
                        });
                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method children
             @chainable

             @param [pSelector] - any type of tb.Selector parameter
             @param {boolean} [pLocalOnly] - only local children of given tb instance(s)

             @return {object} - tb.Selector instance - for chaining

             .children() method

             for each this[0...n] or this as tb() instance,
             - get all direct children of tb object
             - check them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            children: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;children&#x27;, arguments );

                } else if ( that instanceof tb &amp;&amp; !!that.target[&#x27;nodeType&#x27;] &amp;&amp; !pLocalOnly ) { // it must be a native tb object
                    //console.log( &#x27;children of &#x27;, that.target, tb.dom( &#x27;[data-tb]&#x27;, that.target ) );
                    tb.dom( &#x27;[data-tb]&#x27;, that.target )
                        .forEach(
                            function( pDomNode ) {
                                //console.log( pDomNode, tb.dom( pDomNode ).parents(&#x27;[data-tb]&#x27;)[0] === that.target );

                                if ( tb.dom( pDomNode ).parents(&#x27;[data-tb]&#x27;)[0] === that.target ){
                                    pDomNode.tb
                                        .forEach(function( tbElement ){
                                            [].push.call( ret, tbElement ); // push dom object to tb selector content
                                        });
                                }
                            }
                        );

                } else if ( !!pLocalOnly ){

                    for ( var i in that ){
                        if ( that.hasOwnProperty(i) &amp;&amp; that[i] instanceof tb ){
                            [].push.call( ret, that[i] ); // push tb object to tb selector content
                        }
                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method next
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             next() method

             for each this[0...n] or this as tb() instance,
             - get the direct following sibling of tb instance
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            next: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;next&#x27;, arguments );

                } else { // it must be a native tb object

                    result = that.parent().children();
                    index = [].indexOf.call( result, that );

                    if ( result.length &gt; index + 1 ) {
                        [].push.call( ret, result[ index + 1 ] ); // push dom object to tb selector content
                    }

                }
                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method prev
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             prev() method

             for each this[0...n] or this as tb() instance,
             - get the direct previous sibling of tb instance
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            prev: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;prev&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    index = [].indexOf.call( result, this );

                    if ( index ) {
                        [].push.call( ret, result[ index - 1 ] ); // push dom object to tb selector content
                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method first
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             first() method

             for each this[0...n] or this as tb() instance,
             - get the first child of the tb object parent
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            first: function( pSelector ){

                var that = this,
                    ret = tb( &#x27;&#x27; ),
                    result;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;first&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    [].push.call( ret, result[ 0 ] ); // push dom object to tb selector content

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method last
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             last() method

             for each this[0...n] or this as tb() instance,
             - get the last child of the tb object parent
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            last: function( pSelector ){
                var that = this,
                    ret = tb(&#x27;&#x27;),
                    result;

                if ( that instanceof TbSelector ) {
                    ret = walkSelector( this, &#x27;last&#x27;, arguments );
                } else {
                    result = this.parent().children();
                    [].push.call( ret, result[ result.length - 1 ] ); // push dom object to tb selector content
                }
                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method toArray

             @return {array} - TbSelector elements in a plain array

             toArray() method
             */
            toArray: function(){
                var that = this,
                    result = [].filter.call( that, function(){ return true; } );

                return result;
            },

            /**
             @method filter
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             filter() method

             for each this[0...n] or this as tb() instance,
             - check them against the filter param pParam
             - return TbSelector result set (unique)
             */
            filter: function( pSelector ){

                var that = this,
                    compare = tb( pSelector ), // object array to check against
                    ret = tb();

                if ( !pSelector ) {
                    return that;
                }

                if ( that instanceof TbSelector ) {
                    [].forEach.call(
                        that,
                        function( tbObject ) {
                            if ( -1 &lt; [].indexOf.call( compare, tbObject ) ){
                                [].push.call( ret, tbObject );
                            }
                        }
                    );
                } else if ( that instanceof tb ){
                    if ( -1 &lt; [].indexOf.call( compare, that ) ){
                        [].push.call( ret, that );
                    }
                }

                return ret;
            },

            /**
             @method not
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             not() method

             for each this[0...n] or this as tb() instance,
             - check them against pSelector and remove all that match
             - return TbSelector result set (unique)
             */
            not: function( pSelector ){

                var that = this,
                    compare = tb( pSelector ).toArray(), // object array to check against
                    ret,
                    index;

                if ( that instanceof TbSelector ) {
                    ret = that;
                } else {
                    ret = tb( &#x27;&#x27; );
                    [].push.call( ret, that );
                }

                that.each(
                    check,
                    function( key, tbObject ) {

                        index = [].indexOf.call( ret, tbObject );
                        if (  index &gt; -1 ){
                            [].splice.apply( ret, [ index, 1 ] );
                        }

                    }
                );

                return ret;
            },

            /**
             @method is
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             is() method

             for each this[0...n] or this as tb() instance,
             - check them against tbSelector( pParam ) and remove all that DO NOT match
             - return TbSelector result set (unique)
             */
            is: function( pSelector ){

                var that = this,
                    check = tb( pSelector ).toArray(), // object array to check against
                    ret,
                    index;

                if ( that instanceof TbSelector ) {
                    ret = that;
                } else {
                    ret = tb();
                    [].push.call( ret, that );
                }

                check.forEach(
                    function( tbObject ) {

                        index = [].indexOf.call( ret, tbObject );
                        if (  index === -1 ){
                            [].splice.apply( ret, [ index, 1 ] );
                        }

                    }
                );

                return ret;
            },

            /**
             @method add
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             add() method

             add elements to current result set
             - return TbSelector result set (unique)
             */
            add: function( pSelector ){

                var that = this,
                    check = tb( pSelector ).toArray(), // object array to check against
                    ret,
                    index;


                if ( that instanceof TbSelector ) {
                    ret = that;
                } else {
                    ret = tb( &#x27;&#x27; );
                    [].push.call( ret, that );
                }

                check.forEach(
                    function( tbObject ) {

                        index = [].indexOf.call( ret, tbObject );

                        if (  index === -1 ){ // unique result set...
                            [].push.call( ret, tbObject );
                        }

                    }
                );

                return ret;
            }

        };

    })();

    TbSelector.prototype = {};
    for ( var i in tb.prototype ) if ( tb.prototype.hasOwnProperty(i)){
        TbSelector.prototype[i] = tb.prototype[i];
    }

    return tb;

})();

/**
 @class tb.Event
 @constructor

 @param {string} pEventName - name of event
 @param [pEventData] - data to be appended to this event
 @param {string} [pBubble=l] - bubbling indicator, &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down or any combination

 @return {object} tb.Event instance
 */
tb.Event = function( pEventName, pEventData, pBubble ){
    var that = this;
    that.bubble = pBubble || &#x27;l&#x27;;
    that.data = pEventData || {};
    that.name = pEventName || &#x27;&#x27;;
    that.__stopped__ = that.__immediateStopped__ = false;
}

tb.Event.prototype = {

    /**
     @method stopPropagation
     
     @return {object} tb.Event object

     stop propagation after all handlers on this object have run
     */
    stopPropagation: function(){
        this.__stopped__ = true;
        return this;
    },

    /**
      @method stopImmediatePropagation
     
      @return {object} tb.Event object

      stop propagation immediately after this handler has run
     */
    stopImmediatePropagation: function(){
        this.stopPropagation(); // also stop normal propagation
        this.__immediateStopped__ = true;
        return this;
    }

};

/**
 * document.ready bootstrap
 */
(function(){

    function domReady () {
        tb.bind( document.body ); // find all tb dom nodes and add tb objects if not yet done
    }

    // Mozilla, Opera, Webkit
    if ( document.addEventListener ) {
        document.addEventListener( &quot;DOMContentLoaded&quot;, function(){
            document.removeEventListener( &quot;DOMContentLoaded&quot;, arguments.callee, false);
            domReady();
        }, false );

        // If IE event model is used
    } else if ( document.attachEvent ) {
        // ensure firing before onload
        document.attachEvent(&quot;onreadystatechange&quot;, function(){
            if ( document.readyState === &quot;complete&quot; ) {
                document.detachEvent( &quot;onreadystatechange&quot;, arguments.callee );
                domReady();
            }
        });
    }

})();

;
tb.dom = (function () {

    // Variables
    var regExReturn = /\r/g,
        regExSpaces = /[\x20\t\r\n\f]+/g,
        regExWord = /\S+/g,
        regExHtml = /^&lt;&gt;$/g,
        TbSelector = tb.Selector;

    return function (pSelector, pDomNode) {

        var dom;

        // INTERNAL ONLY Private Functions
        function _addEvent( pDomNode, pEventName, pHandler ) {
            if (pDomNode.attachEvent) {
                pDomNode.attachEvent(&#x27;on&#x27; + pEventName, pHandler);
            } else {
                pDomNode.addEventListener(pEventName, pHandler);
            }
        }

        function _removeEvent( pDomNode, pEventName, pHandler ) {
            if (pDomNode.detachEvent){
                pDomNode.detachEvent(&#x27;on&#x27;+pEventName, pHandler);
            } else {
                pDomNode.removeEventListener(pEventName, pHandler);
            }
        }

        function _htmlToElements(html) {
            var template = document.createElement(&#x27;template&#x27;);
            template.innerHTML = html;
            return template.content.childNodes;
        }

        function _mapArrayMethod( pMethodName ){
            var method = [][pMethodName];

            return function(){
                var arr = this.toArray(),
                    ret = method.apply( arr, arguments );

                return (new tb.dom( ret )).unique();
            };
        }

        /**
         @class tb.dom
         @constructor

         @param [pSelector] a .querySelectorAll() selector string, a dom node or an array of dom nodes
         @param [pDomNode] - DOM node to start search in

         @return {object} - tb.dom() result set, may be empty

         tb.dom() function

         jquery like selector engine

         */

        dom = function tbDom(pSelector, pDomNode) {

            var that = this,
                domNode,
                nodeList;

            if (!pSelector) { // no selector given, or not a string
                return;
            } else if (!!pSelector[&#x27;nodeType&#x27;]) { // selector is a dom node
                [].push.call(that, pSelector);
                return;
            } else if (!!pSelector[0] &amp;&amp; pSelector[0] instanceof TbSelector) { // a twobirds selector result set
                [].forEach.call(
                    pSelector,
                    function (pElement) {   // copy only DOM nodes
                        if (!!pElement[&#x27;target&#x27;]
                            &amp;&amp; !!pElement[&#x27;target&#x27;][&#x27;nodeType&#x27;]
                        ) {
                            [].push.call(that, pElement);
                        }
                    }
                );
                return;
            } else if (pSelector instanceof Array
                || pSelector instanceof HTMLCollection
                || pSelector instanceof NodeList ) {
                [].forEach.call(
                    pSelector,
                    function (pElement) {   // copy only DOM nodes
                        if (!!pElement &amp;&amp; !!pElement[&#x27;nodeType&#x27;]) {
                            [].push.call(that, tb.dom( pElement )[0] );
                        }
                    }
                );
                return;
            } else if (typeof pSelector !== &#x27;string&#x27;) { // wrong selector type
                return;
            } else { // pSelector is a string

                var DOM = _htmlToElements( pSelector );

                if ( DOM.length === 1 &amp;&amp; DOM[0].nodeType === 3 ){ // it is not an HTML string

                    domNode = pDomNode &amp;&amp; !!pDomNode[&#x27;nodeType&#x27;] ? pDomNode : document;

                    pSelector
                        .split( &#x27;,&#x27; )
                        .forEach(
                            function forEachTbDomSelector( pThisSelector ){
                                nodeList = domNode.querySelectorAll(pSelector);

                                if (!!nodeList.length) {
                                    [].forEach.call(
                                        nodeList,
                                        function (domElement) {
                                            that[that.length] = domElement;
                                            that.length++;
                                        }
                                    );
                                }

                            }
                        );

                } else { // it is an HTML string

                    return new tb.dom( DOM );

                }
            }

        };

        // dom prototype, public functions
        dom.prototype = {

            length: 0,

            // from Array prototype
            /**
             @method concat
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat&quot;&gt;concat&lt;/a&gt;
             */
            concat: _mapArrayMethod( &#x27;concat&#x27; ),

            /**
             @method every
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;every&lt;/a&gt;
             */
            every: _mapArrayMethod( &#x27;every&#x27; ),

            /**
             @method forEach
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;forEach&lt;/a&gt;
             */
            forEach: _mapArrayMethod( &#x27;forEach&#x27; ),

            /**
             @method indexOf

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;indexOf&lt;/a&gt;
             */
            indexOf: _mapArrayMethod( &#x27;indexOf&#x27; ),

            /**
             @method lastIndexOf

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf&quot;&gt;lastIndexOf&lt;/a&gt;
             */
            lastIndexOf: _mapArrayMethod( &#x27;lastIndexOf&#x27; ),

            /**
             @method map

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;map&lt;/a&gt;
             */
            map: _mapArrayMethod( &#x27;map&#x27; ),

            /**
             @method pop

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop&quot;&gt;pop&lt;/a&gt;
             */
            pop: _mapArrayMethod( &#x27;pop&#x27; ),

            /**
             @method reduce

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;reduce&lt;/a&gt;
             */
            reduce: _mapArrayMethod( &#x27;reduce&#x27; ),

            /**
             @method reduce

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight&quot;&gt;reduceRight&lt;/a&gt;
             */
            reduceRight: _mapArrayMethod( &#x27;reduceRight&#x27; ),

            /**
             @method reverse

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse&quot;&gt;reverse&lt;/a&gt;
             */
            reverse: _mapArrayMethod( &#x27;reverse&#x27; ),

            /**
             @method shift

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift&quot;&gt;shift&lt;/a&gt;
             */
            shift: _mapArrayMethod( &#x27;shift&#x27; ),

            /**
             @method slice

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;slice&lt;/a&gt;
             */
            slice: _mapArrayMethod( &#x27;slice&#x27; ),

            /**
             @method some

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;some&lt;/a&gt;
             */
            some: _mapArrayMethod( &#x27;some&#x27; ),

            /**
             @method splice

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice&quot;&gt;splice&lt;/a&gt;
             */
            splice: _mapArrayMethod( &#x27;splice&#x27; ),

            /**
             @method some

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift&quot;&gt;unshift&lt;/a&gt;
             */
            unshift: _mapArrayMethod( &#x27;unshift&#x27; ),

            //own functions, documented in code below
            add: add,
            addClass: addClass,
            append: append,
            appendTo: appendTo,
            attr: attr,
            children: children,
            descendants: descendants,
            empty: empty,
            hide: hide,
            html: html,
            insertBefore: insertBefore,
            insertAfter: insertAfter,
            removeClass: removeClass,
            filter: filter,
            not: not,
            off: off,
            on: on,
            one: one,
            parent: parent,
            parents: parents,
            push: push,
            removeAttr: removeAttr,
            show: show,
            toArray: toArray,
            trigger: trigger,
            unique: unique,
            val: val
        };

        return new dom( pSelector, pDomNode );

        // Private Functions, exposed

        /**
         @method appendTo

         @param [pElement] a .querySelectorAll() selector string, a dom node or an array of dom nodes

         appends all elements in tb.dom() result set to given DOM nodes
         */
        function appendTo( pElement ){
            var that = this;

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode[&#x27;nodeType&#x27;] ){
                        if ( !pElement.length ){
                            pElement= [ pElement ];
                        }

                        [].forEach.call(
                            pElement,
                            function( pThisElement ){
                                if ( !!pThisElement[&#x27;nodeType&#x27;] ){
                                    pThisElement.appendChild( pDomNode );
                                }
                            }
                        );
                    }
                }
            );

            return that;
        }

        /**
         @method append
         @chainable

         @param [pElement] an array like set of DOM nodes, or a single DOM node

         @return {object} - tb.dom() result set, may be empty

         appends given DOM nodes to every node in tb.dom() result set
         */
        function append( pElement ){
            var that = this;

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType ){
                        if ( !pElement.length ){
                            pElement= [ pElement ];
                        }

                        [].forEach.call(
                            pElement,
                            function( pThisElement ){
                                if ( !!pThisElement[&#x27;nodeType&#x27;] ){
                                    pDomNode.appendChild( pThisElement );
                                }
                            }
                        );
                    } else if ( typeof pElement === &#x27;string&#x27; &amp;&amp; regExHtml.match(pElement) ){
                        tb.dom( pDomNode ).append( tb.dom( pElement ) );
                    }
                }
            );

            return that;
        }

        /**
         @method insertBefore

         @param [pElement] - a single DOM node

         prepends all elements in tb.dom() result set to given DOM node
         */
        function insertBefore( pTarget ){
            var that = this;

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType &amp;&amp; !!pTarget.nodeType ){

                        pTarget.parentElement
                            .insertBefore(
                                pDomNode.cloneNode( true ),
                                pTarget
                            );

                    }
                }
            );

            return that;
        }

        /**
         @method insertAfter

         @param [pElement] - a single DOM node

         inserts all elements in tb.dom() result set after given DOM node
         */
        function insertAfter( pTarget ){
            var that = this,
                nextDomNode = pTarget.nextSibling || false;

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType ){

                        if ( nextDomNode ){
                            pTarget
                                .parentElement
                                .insertBefore(
                                    pDomNode.cloneNode( true ),
                                    nextDomNode
                                );
                        } else {
                            pTarget
                                .parentElement
                                .appendChild(
                                    pDomNode.cloneNode( true )
                                );
                        }

                    }
                }
            );

            return that;
        }

        /**
         @method trigger
         @chainable

         @param {string} pEventName - name of the event
         @param [pData] - optional data

         @return {object} - tb.dom() result set, may be empty

         creates a DOM event for each element in tb.dom() result set
         */
        function trigger( pEventName, pData ){
            var that = this,
                eventNames = pEventName.split(&#x27; &#x27;);

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType ){
                        eventNames.forEach(
                            function( pThisEventName ){
                                if (&#x27;createEvent&#x27; in document) {
                                    var e = document.createEvent(&#x27;HTMLEvents&#x27;);
                                    e.data = pData;
                                    e.initEvent(pThisEventName, false, true);
                                    pDomNode.dispatchEvent(e);
                                } else {
                                    var e = document.createEventObject();
                                    e.data = pData;
                                    e.eventType = pThisEventName;
                                    pDomNode.fireEvent(&#x27;on&#x27;+e.pThisEventName, e);
                                }
                            }
                        );
                    }
                }
            );

            return that;
        }

        /**
         @method on
         @chainable

         @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
         @param {function} pHandler - callback far event

         @return {object} - tb.dom() result set, may be empty

         creates a DOM event handler for each element in tb.dom() result set
         */
        function on( pEventName, pHandler ){
            var that = this,
                eventNames = pEventName.indexOf(&#x27; &#x27;) &gt; -1 ? pEventName.split(&#x27; &#x27;) : [ pEventName ],
                onceHandler;

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType ){
                        eventNames.forEach(
                            function( pThisEventName ){

                                if ( !!pHandler[&#x27;once&#x27;] ){
                                    onceHandler = (function(pDomNode, pThisEventName, pHandler) {
                                        return function(){
                                            _removeEvent( pDomNode, pThisEventName, onceHandler );
                                            pHandler.apply( pDomNode, arguments );
                                        }
                                    })(pDomNode, pThisEventName, pHandler);
                                }

                                _addEvent( pDomNode, pThisEventName, onceHandler || pHandler );
                            }
                        );
                    }
                }
            );

            return that;
        }

        /**
         @method one
         @chainable

         @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
         @param {function} pHandler - callback far event

         @return {object} - tb.dom() result set, may be empty

         creates a DOM event handler for each element in tb.dom() result set (to be called only once)
         */
        function one( pEventName, pHandler ){
            var that = this;

            pHandler.once = true;

            that.on( pEventName, pHandler );

            return that;
        }

        /**
         @method off
         @chainable

         @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
         @param {function} pHandler - callback far event

         @return {object} - tb.dom() result set, may be empty

         removes one or all DOM event handlers from each element in tb.dom() result set
         */
        function off( pEventName, pHandler ){
            var that = this,
                eventNames = pEventName.indexOf(&#x27; &#x27;) &gt; -1 ? pEventName.split(&#x27; &#x27;) : [ pEventName ];

            that.forEach(
                function( pDomNode ){
                    if ( !!pDomNode.nodeType ){
                        if ( !!pHandler ){
                            eventNames.forEach(
                                function( pThisEventName ){
                                    _removeEvent( pDomNode, pThisEventName, pHandler );
                                }
                            );
                        } else {
                            // todo: remove all event handlers
                        }
                    }
                }
            );

            return that;
        }

        /**
         @method empty
         @chainable

         @return {object} - tb.dom() result set, may be empty

         removes one or all DOM event handlers from each element in tb.dom() result set
         */
        function empty() {
            var that = this;

            that.forEach(
                function( pNode ){
                    pNode.innerHTML = &#x27;&#x27;;
                }
            );

            return that;
        }

        /**
         @method html
         @chainable

         @param {string} pHtml - html string or empty string

         @return {object} - tb.dom() result set, may be empty

         replace all nodes .innerHTML with pHtml
         */
        function html( pHtml ) {
            var that = this;

            if ( !!pHtml ){
                if ( typeof pHtml === &#x27;string&#x27; ) {
                    that.forEach(
                        function (pNode) {
                            pNode.innerHTML = pHtml;
                        }
                    )
                }
            } else {
                return !!that[0] ? that[0].innerHTML : &#x27;&#x27;;
            }

            return that;
        }

        /**
         @method hide
         @chainable

         @return {object} - tb.dom() result set, may be empty

         hide all nodes in tb.dom() result set
         */
        function hide() {
            var that = this;

            that.forEach(
                function( pNode ){
                    pNode.style.prevDisplay = ([ &#x27;&#x27;, &#x27;none&#x27;]).indexOf( pNode.style.display ) === -1
                        ? pNode.style.display
                        : &#x27;&#x27;;
                    pNode.style.display = &#x27;none&#x27;;
                }
            );

            return that;
        }

        /**
         @method show
         @chainable

         @return {object} - tb.dom() result set, may be empty

         show all nodes in tb.dom() result set
         */
        function show() {
            var that = this;

            that.forEach(
                function( pNode ){
                    pNode.style.display = pNode.style.prevDisplay;
                }
            );

            return that;
        }

        /**
         @method unique
         @chainable

         @return {object} - tb.dom() result set, may be empty

         force this tb.dom() result set to be unique ( HINT: if this is necessary, there is an error in twoBirds,
         and we would like to hear about it... )

         method is called internally though to force result set uniqueness
         */
        function unique() {
            var that = this,
                result = [];

            [].forEach.call(
                that,
                function ( pElement ) {
                    if ( result.indexOf( pElement ) === -1 ){
                        result.push( pElement );
                    }
                }
            );

            return new tb.dom( result );
        }

        /**
         @method not
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         remove all nodes from this tb.dom() result set, that are in tb.dom( pSelector ) result set
         */
        function not(pSelector) {
            var that = this,
                result = new tb.dom(),
                check = pSelector !== undefined ? document.querySelectorAll( pSelector ) : false;

            if ( !check ){
                return that;
            }

            that.forEach(function (pElement) {
                if ( -1 === [].indexOf.call( check, pElement) ) {
                    result.add(pElement);
                }
            });

            return result;
        }

        /**
         @method add
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         add all nodes in tb.dom( pSelector ) result set to tb.dom() result set
         */
        function add(pElements) {
            var that = this,
                result;

            if (pElements instanceof Array) { // if array given add each of its elements
                pElements.forEach(
                    function (pElement) {
                        that.add(pElement);
                    }
                );
            } else if (!!pElements[&#x27;nodeType&#x27;]) { // if DOM node given add it
                that.push(pElements);
            } else if (typeof pElements === &#x27;string&#x27;) { // DOM selector given add its results
                that.add(new tb.dom(pElements).toArray());
            }

            result = that.unique();

            return result;
        }

        /**
         @method parents
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         return all parent nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
         */
        function parents(pSelector) {

            var that = this,
                result = new tb.dom(),
                check = pSelector !== undefined ? document.querySelectorAll( pSelector ) : false,
                nextNode;

            that.forEach(
                function (pDomNode) {
                    var domNode = pDomNode.parentNode;

                    while (!!domNode
                    &amp;&amp; !!domNode[&#x27;tagName&#x27;]
                    &amp;&amp; domNode[&#x27;tagName&#x27;] !== &#x27;html&#x27;
                        ){
                        nextNode = domNode.parentNode;
                        if ([].indexOf.call(result, domNode) === -1
                            &amp;&amp; ( !check || -1 &lt; [].indexOf.call( check, domNode ) )
                        ) {
                            result.push(domNode);
                        }
                        domNode = nextNode;
                    }
                }
            );

            return result;
        }

        /**
         @method parent
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         return closest parent nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
         */
        function parent(pSelector){
            var that = this,
                result = new tb.dom(),
                check = pSelector !== undefined ? document.querySelectorAll( pSelector ) : false;

            that.forEach(
                function (pDomNode) {
                    var domNode = pDomNode.parentNode;

                    if ( -1 === [].indexOf.call( result, domNode )
                        &amp;&amp; ( !check ||  -1 &lt; [].indexOf.call( check, domNode ) )
                    ){
                        [].push.call( result, domNode);
                    }
                }
            );

            return result;
        }

        /**
         @method children
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         return child nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
         */
        function children(pSelector) {

            var that = this,
                result = new tb.dom();

            that.forEach(
                function (pDomNode) {
                    var check = pSelector !== undefined ? pDomNode.querySelectorAll( pSelector ) : false;

                    [].forEach.call(
                        pDomNode.children,
                        function( pChildNode ){
                            if ( -1 === [].indexOf.call( result, pChildNode )
                                &amp;&amp; ( !check || -1 &lt; [].indexOf.call( check, pChildNode ) )
                            ){
                                result.push( pChildNode );
                            }
                        }
                    );
                }
            );

            return result;
        }

        /**
         @method descendants
         @chainable

         @param  pSelector - any valid tb.dom() constructor parameter

         @return {object} - tb.dom() result set, may be empty

         return all descendant nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
         */
        function descendants(pSelector) {

            var that = this,
                result = new tb.dom();

            that.forEach(
                function (pDomNode) {
                    var check = pSelector !== undefined ? pDomNode.querySelectorAll( pSelector ) : false;

                    [].forEach.call(
                        pDomNode.querySelectorAll( pSelector || &#x27;*&#x27; ),
                        function( pDescendantNode ){
                            if ( -1 === [].indexOf.call( result, pDescendantNode )
                                &amp;&amp; ( !check || -1 &lt; [].indexOf.call( check, pDescendantNode ) )
                                ){
                                result.push( pDescendantNode );
                            }
                        }
                    );
                }
            );

            return result;
        }

        /**
         @method addClass
         @chainable

         @param  {string} pClassName - class name(s) to add, separated by &#x27; &#x27;

         @return {object} - tb.dom() result set, may be empty

         add class name to each of tb.dom() result set
         */
        function addClass(pClassName) {

            var that = this;

            that.forEach(
                function (pDomNode) {
                    var classes = pDomNode.getAttribute(&#x27;class&#x27;) || &#x27;&#x27;,
                        classes = !!classes.length ? classes.split(&#x27; &#x27;) : [],
                        index = classes.indexOf(pClassName);

                    if (index === -1) {
                        classes.push( pClassName );
                        pDomNode.setAttribute(&#x27;class&#x27;, classes.join(&#x27; &#x27;) );
                    }
                }
            );

            return that;
        }

        /**
         @method removeClass
         @chainable

         @param  {string} pClassName - class name(s) to remove, separated by &#x27; &#x27;

         @return {object} - tb.dom() result set, may be empty

         remove class name from each of tb.dom() result set
         */
        function removeClass(pClassName) {

            var that = this;

            that.forEach(
                function (pDomNode) {
                    var classes = pDomNode.getAttribute(&#x27;class&#x27;) || &#x27;&#x27;;

                    if ( classes ){
                        if ( !!(classes.indexOf(&#x27; &#x27;) + 1) ){
                            classes = classes.split(&#x27; &#x27;)
                        } else {
                            classes = [ classes ];
                        }

                        pClassName.split(&#x27; &#x27;)
                            .forEach(
                                function( pRemoveClass ){
                                    while ( classes.indexOf(pRemoveClass) &gt; -1 ){
                                        classes.splice(classes.indexOf(pRemoveClass), 1)
                                    }
                                }
                            );

                        if ( !!classes.length ){
                            tb.dom( pDomNode ).attr(&#x27;class&#x27;, classes.join(&#x27; &#x27;) )
                        } else {
                            tb.dom( pDomNode ).removeAttr(&#x27;class&#x27;);
                        }
                    }

                }
            );

            return that;
        }

        /**
         @method attr
         @chainable

         @param pKey - if string: DOM node attribute name; if object: hash of attributeName: attributeValue
         @param {string} [pValue] - value to set in DOM node(s)

         @return {object} - tb.dom() result set, may be empty

         set of get attribute values to each DOM node in give tb.dom() result set

         HINT:
         if pKey is a string and pValue is not given its a GET
         if pKey is an object or pKey(string) and pValue(string) are given, it is a SET. ONLY THEN this is CHAINABLE.
         */
        function attr(pKey, pValue) {

            var that = this,
                rootNodes;

            if ( pKey.constructor === Object ){ // hash given

                Object
                    .keys( pKey )
                    .forEach(
                        function( thisKey ){
                            that.attr( thisKey, pKey[thisKey] );
                        }
                    );

            } else { // key/value pair expected

                // if no value is given and there are elements, return attribute value of first in list
                if (!pValue &amp;&amp; that.length &gt; 0) {
                    return that[0].getAttribute(pKey);
                }

                // if a value to set is given, apply to all nodes in list
                rootNodes = that.toArray();
                rootNodes.forEach(
                    function (pNode) {
                        if ( pKey.constructor === Object ){
                            Object
                                .keys( pKey )
                                .forEach(
                                    function( thisKey ){
                                        pNode.setAttribute( thisKey, pKey[thisKey] );
                                    }
                                );
                            return;
                        } else {
                            pNode.setAttribute(pKey, pValue);
                        }
                    }
                );

            }

            return that;
        }

        /**
         @method removeAttr
         @chainable

         @param {string} pKeys - attribute name(s) separated by &#x27; &#x27;

         @return {object} - tb.dom() result set, may be empty

         remove attribute(s) completely from tb.dom() result set
         */
        function removeAttr(pKeys) {

            var that = this,
                attrNames = pKeys &amp;&amp; pKeys.match(regExWord),
                name,
                i;

            that.forEach(
                function (pDomNode) {
                    i = 0;
                    if (attrNames &amp;&amp; !!pDomNode[&#x27;nodeType&#x27;] &amp;&amp; pDomNode.nodeType === 1) {
                        while ((name = attrNames[i++])) {
                            pDomNode.removeAttribute(name);
                        }
                    }
                }
            );

            return that;
        }

        /**
         @method toArray
         @chainable

         @return {array} - tb.dom() result set converted to a plain array of DOM nodes

         convert tb.dom() result set converted to a plain array of DOM nodes
         */
        function toArray() {

            var that = this,
                result = [];

            if (!!that.length) {
                [].map.call(
                    that,
                    function (pElement) {
                        result.push(pElement);
                    }
                );
            }

            return result;

        }

        /**
         @method filter
         @chainable

         @param pSelector - tb.dom() selector to match against or [].filter.call( this, function(){ ... } )

         @return {object} - tb.dom() result set

         match tb.dom() result set against pSelector filter
         */
        function filter( pSelector ) {

            var that = this,
                compare = new tb.dom( pSelector ),// functions and undefined will be ignored, so empty result then
                result;

            if ( pSelector === &#x27;undefined&#x27; ) return that;    // unchanged

            if ( typeof pSelector === &#x27;string&#x27; ) { // DOM selector given
                result = [].filter.call(
                    that,
                    function (pElement) {
                        return -1 &lt; compare.indexOf(pElement);
                    }
                );
            } else if ( typeof pSelector === &#x27;function&#x27; ) { // function given
                result = [].filter.call(
                    that,
                    pSelector
                );
                return result;
            }

            return new tb.dom(result);

        }

        /**
         @method push
         @chainable

         @param pSelector - tb.dom() selector or DOM node

         @return {object} - tb.dom() result set

         add given pSelector result set to tb.dom() result set
         */
        function push(pSelector) {

            var that = this,
                result = [];

            // todo: is this necessary? see .add()

            if (typeof pSelector === &#x27;undefined&#x27;) return that;    // unchanged

            if (pSelector instanceof Array) { // if array given add each of its elements
                pSelector.forEach(
                    function (pElement) {
                        that.push(pElement);
                    }
                );
            } else if (!!pSelector[&#x27;nodeType&#x27;]) { // if DOM node given add it
                [].push.call(that, pSelector);
            } else if (typeof pSelector === &#x27;string&#x27;) { // DOM selector given add its results
                that.push(new tb.dom(pSelector).toArray());
            }

            result = that.unique();

            return result;
        }

        /**
         @method val
         @chainable

         @param {string} [pValue] - value to set to DOM input type element

         @return [pValue] - value from input element [0] in tb.dom() result set

         if pValue given, it is a SET and the method is chainable
         if no pValue given, it is a GET and the method will return the value
         */
        function val( pValue ){

            var that = this,
                ret;

            var valHandlers = {

                &#x27;select&#x27;: function selectVal( pValue ){

                    var that = this,
                        multiSelect = that.type === &quot;select-multiple&quot;,
                        ret;

                    if ( !arguments.length ) { // getter

                        ret = [];

                        tb.dom( &#x27;option:selected&#x27;, that)
                            .forEach(
                                function( pThisSelectedOption ){
                                    if ( !option.disabled
                                        &amp;&amp; ( !option.parentNode.disabled
                                        || option.parentNode.nodeName !== &quot;optgroup&quot; )
                                    ){
                                        var value = pThisSelectedOption.value;

                                        if ( !multiSelect ) {
                                            return value;
                                        }

                                        ret.push( value );
                                    }                                    }
                            );

                        return ret;

                    } else { // setter

                        // if single value given convert to array
                        pValue = multiSelect &amp;&amp; pValue.constructor !== Array ? [ pValue ] : pValue;

                        // if not multiSelect but array given set array to first value
                        pValue = !multiSelect &amp;&amp; pValue.constructor === Array ? [ pValue[0] ] : pValue;

                        // remove all &#x27;selected&#x27; attributes
                        tb.dom( &#x27;option&#x27;, that )
                            .removeAttr( &#x27;selected&#x27; );

                        // set given &#x27;selected&#x27; attributes
                        pValue
                            .forEach(
                                function( pThisOptionValue ){
                                    tb.dom( &#x27;option[value=&quot;&#x27; + pThisOptionValue + &#x27;&quot;]&#x27;, that )
                                        .attr( { &#x27;selected&#x27;: &#x27;selected&#x27; } );
                                }
                            );

                    }

                    return that;
                },

                &#x27;default&#x27;:function defaultVal( pValue ){

                    var that = this,
                        ret;

                    if ( ([ &#x27;radio&#x27;, &#x27;checkbox&#x27; ]).indexOf( that.type ) &gt; -1 ){ // input radio or checkbox

                        if ( !!arguments.length ){ // setter
                            that.checked = !!pValue;
                        }

                        return that.checked; // getter

                    } else {

                        if ( !arguments.length ) { // getter

                            ret = that.value;

                            return typeof ret === &quot;string&quot; ?
                                ret :
                                ret == null ? &quot;&quot; : ret;

                        } else { // setter

                            // Treat null/undefined as &quot;&quot;; convert numbers to string
                            if (pValue == null) {
                                pValue = &quot;&quot;;
                            } else if (typeof val === &quot;number&quot;) {
                                pValue += &quot;&quot;;
                            }

                            that.value = pValue;

                        }

                    }

                }

            };

            if ( arguments.length ){

                that.forEach(
                    function ( pElement ) {

                        var inputTags = [ &#x27;input&#x27;, &#x27;select&#x27;, &#x27;option&#x27;, &#x27;textarea&#x27;];

                        if ( pElement.nodeType !== 1
                            || ( inputTags ).indexOf( pElement.tagName.toLowerCase() ) === -1
                        ){
                            return; // not an input element
                        }

                        ret = !!valHandlers[ pElement.tagName.toLowerCase() ]
                            ? valHandlers[ pElement.tagName.toLowerCase() ].call( pElement, pValue )
                            : valHandlers[ &#x27;default&#x27; ].call( pElement, pValue );

                    }
                );

                return that;

            } else { // getter

                that.some(
                    function ( pElement ) {

                        var inputTags = [ &#x27;input&#x27;, &#x27;select&#x27;, &#x27;option&#x27;, &#x27;textarea&#x27;];

                        if ( pElement.nodeType !== 1
                            || ( inputTags ).indexOf( pElement.tagName.toLowerCase() ) === -1
                        ){
                            return false; // not an input element
                        }

                        ret = !!valHandlers[ pElement.tagName.toLowerCase() ]
                            ? valHandlers[ pElement.tagName.toLowerCase() ].call( pElement )
                            : valHandlers[ &#x27;default&#x27; ].call( pElement );

                        return true; // not an input element

                    }
                );

                return ret;

            }

        }

    };
})();

;
/*
YOU MUST KEEP THE ORDER IN THIS FILE!
-functions depend on sequence of appearence partly
*/

/**
 @class tb.Util
 @constructor
 
 @param {void}

 @return {void}

 THIS IS A PLACEHOLDER CLASS!

 - all methods and properties documented here are curry properties of the tb constructor.
 - Refer to specific documentation for usage.

 @example
    // see methods
 
 */

/**
 @method tb.observable

 @param pStartValue - initial content of observable

 @return {function} - observableFunction

 function tb.observable()

 - creates a function
 - initializes a value to observe
 - returns this function

 @example

     o = tb.observable( {} );

     o(
        { newData: &#x27;newData&#x27; }
     ); // change observable value

     o.observe( function(){ ... }, true ); // will be triggered when observable value changes, true indicates only once

 */
tb.observable = function( pStartValue ){

    var observedValue = pStartValue;

    // make observable function to return in the end
    var observableFunction = function( pValue ){

        if ( pValue !== undefined ){ // value has changed
            observedValue = pValue;
            observableFunction.notify();
        }
        return observedValue;
    };

    // list of all callbacks to trigger on observedValue change
    observableFunction.list = [];

    // function used to execute all callbacks
    observableFunction.notify = function(){

        // execute all callbacks
        observableFunction.list.forEach(
            function( func, key ){
                if ( typeof func === &#x27;function&#x27; ){
                    func( observedValue );
                    if ( func.once ){
                        observableFunction.list.splice(key,1);
                    }
                } else {
                    observableFunction.list.splice(key,1);
                }
            }
        );

    };

    // function used to add a callbacks
    observableFunction.observe = function( pFunction, pOnce ){
        pFunction.once = pOnce || false;
        observableFunction.list.push( pFunction );
    };

    return observableFunction;
};


/**
 @method  tb.namespace

 @param {string} pNamespace
 @param {boolean} [pForceCreation] - true =&gt; force creation of namespace object if it didnt exist before
 @param {object} [pObject] - object to scan

 @return {Object}        namespaceObject

 tb.namespace() function

 @example

     // lookup [window] namespace:
     tb.namespace( &#x27;app.Dashboard&#x27; ); // gets the constructor for dashboard

     // in a constructor force namespace creation:
     tb.namespace( &#x27;app&#x27;, true )     // force creation of &#x27;app&#x27; if it is not there yet
     .Dashboard = function(){ ... }

     // lookup namespace in any object and return value:
     tb.namespace( &#x27;x.y&#x27;, null, { x: { y: 42 } } );     // 42
 
 */
tb.namespace = function( pNamespace, pForceCreation, pObject ){

    if ( typeof pNamespace !== &#x27;string&#x27; ){
        return false;
    }

    var namespaceArray = pNamespace.split(&#x27;.&#x27;);

    var walk = function( o, namespaceArray ) {

        if ( !o[ namespaceArray[0] ] &amp;&amp; !!pForceCreation ) {
            o[ namespaceArray[0] ] = {};
        }

        if ( namespaceArray.length &lt; 2 ){

            return o.hasOwnProperty( namespaceArray[0] ) ? o[ namespaceArray[0] ] : false;

        } else {

            if ( o.hasOwnProperty( namespaceArray[0] ) ) {
                o = o[ namespaceArray[0] ];
                namespaceArray.shift();
                return walk( o, namespaceArray );
            } else {
                return false;
            }

        }
    };

    return walk( !pObject ? window : pObject, namespaceArray );

};


/**
 @method tb.bind

 @param   {object} pRootNode - DOM node to start binding in

 @return {void}

 tb.bind() function

 @example

     tb.bind( document.body );
     // scans the given element and all of its descendants
     // in the DOM and looks for attributes &quot;data-tb&quot; in the nodes.

     // Resulting list will be scanned for those nodes that do not already
     // have a tb object inside which is given as a namespace in the data-tb attribute.

     // Creates missing tb object based on the class namespace given
     // in the &quot;data-tb&quot; attribute and stores it in the DOM element
    
 */
tb.bind = function( pRootNode ){

    var rootNode = pRootNode || document.body,
        foundElements = rootNode.querySelectorAll( &#x27;[data-tb]&#x27; );

    // add self if data-tb attribute present
    if ( rootNode.getAttribute(&#x27;data-tb&#x27;) ){
        foundElements = [].concat.call( [ rootNode ], tb.dom().toArray.call( foundElements ) );
    }

    // instanciate tb instances for given elements
    foundElements.forEach(
        function( pElement ){
            var namespaces = pElement.getAttribute(&#x27;data-tb&#x27;).split(&#x27; &#x27;);

            namespaces.forEach(
                function( pNamespace ){
                    pElement[&#x27;tb&#x27;] = pElement[&#x27;tb&#x27;] || {};
                    if ( !pElement[&#x27;tb&#x27;][pNamespace] ){
                        new tb(        // create tb object
                            pNamespace,
                            null,
                            pElement
                        );
                    }
                }
            );

        }
    );

};



// twoBirds system status
tb.status = {
    loadCount: tb.observable(0)
};

/*
 // debugging...
 tb.status.loadCount.observe(function(){
 console.log( &#x27;loadCount:&#x27;, tb.status.loadCount() );
 });
 */

tb.idle = function( pCallback ){

    var f = function(){
        if ( tb.status.loadCount() === 0 ){
            pCallback();
        } else {
            // if idle not yet reached, re-atttach function for ONE execution
            tb.status.loadCount.observe( f, true );
        }
    };

    tb.status.loadCount.observe( f, true );

};


/**
 @method tb.getId

 @return {string} - unique id

 returns a unique id
 */
tb.getId = function(){
    return &#x27;id-&#x27; + (new Date()).getTime() + &#x27;-&#x27; + Math.random().toString().replace(/\./, &#x27;&#x27;);
};



/**
 @method tb.extend

 @param {object} pObj - object to extend
 @param {object} [pObj] - other object

 @return {object} - other object

 tb.extend() function

 takes any number of objects as parameters
 merges content into the first parameter object
 always a deep copy
 */
tb.extend = function( pObj ){ // any number of arguments may be given
    var cp;

    while ( arguments[1] ){
        cp = arguments[1];
        Object
            .keys(cp)
            .forEach(
                function(key) {
                    if ( cp[key] !== null
                        &amp;&amp; !!cp[key][constructor]
                        &amp;&amp; (cp[key]).constructor === Object
                    ){
                        pObj[key] = tb.extend( pObj[key] || {}, cp[key] );
                    } else {
                        pObj[key] = cp[key];
                    }
                }
            );
        [].splice.call( arguments, 1, 1 ); // remove object that is done
    }

    return pObj;
};



/**
 @method tb.parse
  
 @param pWhat - text, object or array to parse
 @param {object} pParse - hash object containing replacement key/value pairs

 @return result, = pWhat parsed

 tb.parse() function

 will replace all matching {namespace1.namespace2.etc} occurrences with values from pParse object
 if typeof pWhat is object or array, it will be done with all strings contained therein and the original pWhat returned
 */
tb.parse = function( pWhat, pParse ){

    if ( typeof pWhat === &#x27;string&#x27; ){
        var vars = pWhat.match( /\{[^\{\}]*\}/g );

        if ( !!vars ) {
            vars
                .forEach(
                    function (pPropname) {
                        var propname = pPropname.substr(1, pPropname.length - 2),
                            propValue = tb.namespace(propname, false, pParse) || propname + &#x27; not found!&#x27;;

                        pWhat = pWhat.replace( pPropname, propValue );
                    }
                );
        }
    } else if ( !!pWhat.constructor ){
        switch ( pWhat.constructor ){
            case Object:
                Object
                    .keys( pWhat )
                    .forEach(
                        function( pKey ){
                            if ( pWhat.hasOwnProperty( pKey ) ){
                                pWhat[ pKey ] = tb.parse( pWhat[ pKey ], pParse );
                            }
                        }
                    );
                break;
            case Array:
                pWhat
                    .forEach(
                        function( pValue, pKey ){
                            pWhat[ pKey ] = tb.parse( pWhat[ pKey ], pParse );
                        }
                    );
                break;
        }
    }

    return pWhat;
};

/**
 @method tb.request

 @param pOptions { object } a hash object containing these options:&lt;br&gt;&lt;br&gt;&lt;br&gt;

 @param pOptions.url: (string, omitted) the URL to call
 @param {object} [pOptions.params] - a hash object containing the parameters to post
 @param {string} [pOptions.method] - (string, optional, defaults to &#x27;POST&#x27;) the XHR method
 @param {object} [pOptions.headers] - a hash object containing additional XHR headers
 @param {function} [pOptions.success] - the function to call with the request result
 @param {function} [pOptions.error] - the function to call if request status not in 200...299
 @param {function} [pOptions.statechange] - the function to call when readyState changes
 @param {number} [pOptions.timeout] - structure sample: { cb: myFunction, ms:10000 }
    cb: callback to run when timeout occurs
    ms: number of milliseconds the request will run before being terminated
 @param {boolean} [pOptions.cachable] - defaults to true, indicates whether or not to include a unique id in URL
 @param {boolean} [pOptions.async] - whether or not to make an asynchronous request

 @returns a twoBirds request object

 */
tb.request = (function () {
    /** @private */
    var loadlist = [],
        readyState = &#x27;complete&#x27;,
        cachable = false,
        log = false,
        count = 0,
        interval = 30,
        msoft = [&#x27;Msxml2.XMLHTTP&#x27;, &#x27;Microsoft.XMLHTTP&#x27;];

    function getConnection(pId) {
        var obj = {},
            xhr,
            getConnection;

        if (typeof ActiveXObject !== &#x27;undefined&#x27;){
            for (var i = 0; i &lt; msoft.length; ++i) {
                try {
                    xhr = new ActiveXObject(msoft[i]);
                    obj = {
                        connection: xhr,
                        identifier: pId
                    };

                    getConnection = (function (pType) {
                        return function (pId) {
                            var http = new ActiveXObject(pType);
                            obj = {
                                connection: xhr,
                                identifier: pId
                            };
                            return obj;
                        };
                    })(msoft[i]);
                } catch (e) {
                }
            }
        }

        try {
            xhr = new XMLHttpRequest();
            obj = {
                connection: xhr,
                identifier: pId
            };
            /** @ignore */
            getConnection = function (pId) {
                var xhr = new XMLHttpRequest();
                obj = {
                    connection: xhr,
                    identifier: pId
                };
                return obj;
            };
        }
        catch (e) {
        }
        finally {
            return obj;
        }
    }

    /** @private */
    function handleReadyState(pReq, pCallback, pStateChange, pFailure, pOptions) {
        var connection = this;
        var poll = window.setInterval((function (pReadyState) {
            return function () {
                if (pReq.connection.readyState !== pReadyState) {
                    pReadyState = pReq.connection.readyState;
                    //pStateChange();
                }
                if (pReadyState === 4) {
                    if (pReq.aborttimer) {
                        window.clearTimeout(pReq.aborttimer);
                    }
                    window.clearInterval(poll);
                    handleTransactionResponse(pReq, pCallback, pFailure, pOptions);
                }
            };
        })(0), interval);

        return poll;
    }

    /** @private */
    function handleTransactionResponse(pReq, pCallback, pFailure, pOptions) {

        try {
            var httpStatus = pReq.connection.status;
        }
        catch (e) {
            var httpStatus = 13030;
        }
        if (httpStatus &gt;= 200 &amp;&amp; httpStatus &lt; 300) {
            var responseObject = createResponseObject(pReq, pOptions);
            try {
                pCallback.call(pCallback, responseObject);
            }
            catch (e) {
                if (tb.debug) debugger;
            }
        }
        else {
            var responseObject = createResponseObject(pReq, tb.extend( {}, pOptions ) );
            pFailure.call( pFailure, responseObject );
        }
        release(pReq);
    }

    /** @private */
    function createResponseObject(pObj, pOptions) {
        var obj = {
            tId: pObj.identifier,
            status: pObj.connection.status,
            statusText: pObj.connection.statusText,
            allResponseHeaders: pObj.connection.getAllResponseHeaders(),
            text: pObj.connection.responseText,
            xml: pObj.connection.responseXML,
            options: pOptions
        };
        return obj;
    }

    /** @private */
    function release(pReq) {
        dec( pReq );
        if (pReq.connection){
            pReq.connection = null;
        }
        delete pReq.connection;
        pReq = null;
        delete pReq;
    }

    function inc( pReq ) {
        loadlist.push( pReq );
        count++;
        readyState = &#x27;loading&#x27;;
    }

    function dec( pReq ) {
        if ( loadlist.indexOf( pReq ) ){
            count--;
            loadlist.splice( loadlist.indexOf( pReq ) );
            if ( count === 0 ){
                readyState = &#x27;complete&#x27;;
            }
        }
    }


    /**
     @name tb.request
     @function
     */
    return function (pOptions) {
        var uid = &#x27;tb&#x27; + tb.getId(),
            xmlreq = false,
            method = (pOptions.method ? pOptions.method.toUpperCase() : false) || &#x27;GET&#x27;,
            url = pOptions.url,
            params = &#x27;&#x27;,
            successHandler = pOptions.success || tb.nop,
            errorHandler = pOptions.error || tb.nop,
            stateHandler = pOptions.statechange || tb.nop,
            isCachable = pOptions.cachable || false,
            timeout = pOptions.timeout || false,
            isAsync = (typeof pOptions.async !== &#x27;undefined&#x27; &amp;&amp; pOptions.async === false) ? false : true;

        if (typeof pOptions.params != &#x27;undefined&#x27;) {
            var ct = ( pOptions.headers &amp;&amp; pOptions.headers[&#x27;Content-Type&#x27;]
                ? pOptions.headers[&#x27;Content-Type&#x27;]
                : &#x27;application/x-www-form-urlencoded&#x27; );

            switch ( ct ){
                case &#x27;application/json&#x27;:
                    params = JSON.stringify( pOptions.params );
                    break;
                default:
                    for (var i in pOptions.params) { // concat parameter string
                        params += ((params.length &gt; 0 ? &#x27;&amp;&#x27; : &#x27;&#x27;) + i + &#x27;=&#x27; + pOptions.params[i]);
                    }
                    break;
            }
        }

        inc();

        /*
         if (isCachable === false) { // proxy disable - cache busting
         url += (url.indexOf(&#x27;?&#x27;) &lt; 0 ? &#x27;?&#x27; : &#x27;&amp;&#x27;) + &#x27;tbUid=&#x27; + uid;
         }
         */

        xmlreq = getConnection(uid);
        if (xmlreq) {
            if ( ( method === &#x27;GET&#x27; || method === &#x27;DELETE&#x27; ) &amp;&amp; params !== &#x27;&#x27;) {
                url = url + (url.indexOf(&#x27;?&#x27;) &lt; 0 ? &#x27;?&#x27; : &#x27;&amp;&#x27;) + params;
            }
            xmlreq.src=url;

            xmlreq.connection.open(method, url, isAsync);

            if (isAsync === true) {
                xmlreq.poll = handleReadyState(xmlreq, successHandler, stateHandler, errorHandler, pOptions);
            }

            // set request headers
            if (pOptions.headers) {
                for (var i in pOptions.headers) {
                    if (i !== &#x27;Content-Type&#x27;) {
                        xmlreq.connection.setRequestHeader(i, pOptions.headers[i]);
                    }
                }
            }

            // abort functionality
            if (timeout) {
                xmlreq.timeoutTimer = window.setTimeout(

                    function (pT, pR) {
                        var f = typeof pT.cb === &#x27;function&#x27; ? pT.cb : false;
                        return function () {
                            //if ( !myR &amp;&amp; myR.connection.status == 4 ) return;
                            if (typeof f == &#x27;function&#x27;) {
                                f( /*createResponseObject(myR)*/ );
                            }
                            pR.connection.abort();
                            window.clearInterval(pR.poll);
                        };
                    }(timeout, xmlreq), timeout.ms);
            }

            xmlreq.abort = ( function(xmlreq) {
                return function () {
                    window.clearInterval(xmlreq.poll);
                    if (xmlreq.connection) xmlreq.connection.abort();
                    release(xmlreq);
                };
            })( xmlreq );

            // send
            if (method === &#x27;POST&#x27; || method === &#x27;PUT&#x27;) {
                if (params !== &#x27;&#x27;) {
                    xmlreq.connection.setRequestHeader(&#x27;Content-Type&#x27;, ct);
                    xmlreq.connection.send(params);
                }
                else {
                    xmlreq.connection.send(null);
                }
            }
            else {
                xmlreq.connection.send(null);
            }
            // if sync request direct handler call
            if (isAsync === false) {
                tb.request.dec();
                if (xmlreq.connection.status &gt;= 200 &amp;&amp; xmlreq.connection.status &lt; 300) {
                    successHandler( xmlreq );
                }
                else {
                    errorHandler( xmlreq );
                }
            }
            else {
                return xmlreq;
            }
            return;
        }
        else {
            return false;
        }
    };

})();


/**
 @method tb.stop

 @param {boolean} pStopit - indicating whether to stop event handling

 @return {boolean} - true if event handling stopped, else false

 stops event handling

 */
tb.stop = (function(pStopIt){
    var stopIt = pStopIt;
    return function( pStopIt ){
        return (stopIt = ( !!pStopIt ? pStopIt : stopIt ) );
    };
})( false );



;
/**
 @class tb.Model
 @constructor

 @param {object} pConfig - config parameter, usually an object @todo param description

 @return {object} - the model instance

 tb.Model constructor
 - create and return a simple CRUD model a &quot;data&quot; observable

 @example

     // templates crud model
     that.templatesModel = new tb.Model({
                &#x27;read&#x27;: {
                    url: &#x27;demoapp/configuration/mock/demoapp-configuration-templates.json&#x27;, // mock data
                    method: &#x27;GET&#x27;,
                    type: &#x27;json&#x27;,
                    params: {
                    },
                    success: function( pResult ){
                        that.templatesModel.data( JSON.parse( pResult.text ).data );
                    },
                    error: function( pResult ){
                        console.log( &#x27;an error occured&#x27;, pResult );
                    }
                }
            });

     // ... and later:

     // when template list data has been read, render
     that.templatesModel.data.observe( function templateModelDataChanged(){
                that.trigger( &#x27;render&#x27; );
            });

     // read data
     that.templatesModel.read();

 @example

     // default config mixin -&gt; result will be in that.config
     tb.extend(
     that.config,
     {   // default settings, reference only
         &#x27;create&#x27;: {
             url: &#x27;&#x27;,
             method: &#x27;POST&#x27;,
             success: function( pResult ){
                 that.data( pResult );
             }
         },
         &#x27;read&#x27;: {
             url: &#x27;&#x27;,
             method: &#x27;GET&#x27;,
             success: function( pResult ){
                 that.data( pResult );
             }
         },
         &#x27;update&#x27;: {
             url: &#x27;&#x27;,
             method: &#x27;PUT&#x27;,
             success: function( pResult ){
                 that.data( pResult );
             }
         },
         &#x27;delete&#x27;: {
             url: &#x27;&#x27;,
             method: &#x27;DELETE&#x27;,
             success: function( pResult ){
                 that.data( pResult );
             }
         }
     },
     pConfig
     );

 */
tb.Model = function ( pConfig ) {
    var that = this;

    // result element
    that.data = tb.observable( {} );
    that.config = {};

    // default config mixin -&gt; result will be in that.config
    tb.extend(
        that.config,
        {   // default settings, reference only
            &#x27;create&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;POST&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;read&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;GET&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;update&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;PUT&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            },
            &#x27;delete&#x27;: {
                url: &#x27;&#x27;,
                method: &#x27;DELETE&#x27;,
                success: function( pResult ){
                    that.data( pResult );
                }
            }
        },
        pConfig
    );

};

tb.Model.prototype = (function(){
    // private

    // create get parameter string
    function makeGetParameterString( pParameterObject ){

        var result=&#x27;&#x27;;

        Object
            .keys( pParameterObject )
            .forEach(
                function( key ) {
                    result += ( !!result ? &#x27;&amp;&#x27; : &#x27;&#x27; ) + key + &#x27;=&#x27; + pParameterObject[key];
                }
            );

        return result;
    }

    return {

        /**
         @method create

         @param {object} [pParameters] - any combination of parameters

         .create() method

         */
        &#x27;create&#x27;: function( pParams ){
            var o = tb.extend( {}, this.config.create );

            if ( !o.url ){
                console.error( &#x27;no create url given!&#x27;);
                return;
            }

            tb.request(
                tb.extend(
                    o,
                    { // if params given, use microparse to fill them in url
                        url: pParams ? tb.parse( this.config.create.url, pParams ) : this.config.create.url
                    },
                    {
                        params: pParams
                    }
                )
            );

        },

        /**
         @method read

         @param {object} [pParameters] - any combination of parameters

         .read() method

         */
        &#x27;read&#x27;: function( pParams ){

            var o = tb.extend( {}, this.config.read );

            if ( !o.url ){
                console.error( &#x27;no read url given!&#x27;);
                return;
            }

            tb.request(
                tb.extend(
                    o,
                    { // if params given, use microparse to fill them in url
                        url: pParams ? tb.parse( this.config.read.url, pParams ) : this.config.read.url
                    },
                    {
                        params: pParams
                    }
                )
            );

        },

        /**
         @method update

         @param {object} [pParameters] - any combination of parameters

         .update() method

         */
        &#x27;update&#x27;: function( pParams ){
            var o = tb.extend( {}, this.config.update );

            if ( !o.url ){
                console.error( &#x27;no update url given!&#x27;);
                return;
            }

            tb.request(
                tb.extend(
                    o,
                    { // if params given, use microparse to fill them in url
                        url: pParams ? tb.parse( this.config.update.url, pParams ) : this.config.update.url
                    },
                    {
                        params: pParams
                    }
                )
            );

        },

        /**
         @method delete

         @param {object} [pParameters] - any combination of parameters

         .delete() method

         */
        &#x27;delete&#x27;: function( pParams ){
            var o = tb.extend( {}, this.config[&#x27;delete&#x27;] );

            if ( !o.url ){
                console.error( &#x27;no delete url given!&#x27;);
                return;
            }

            tb.request(
                tb.extend(
                    o,
                    { // if params given, use microparse to fill them in url
                        url: pParams ? tb.parse( this.config.delete.url, pParams ) : this.config.delete.url
                    },
                    {
                        params: pParams
                    }
                )
            );

        }

    };

})();

;
/**
 @class tb.Require
 @constructor

 @param   {array} pRequiredFiles - array containing required files

 @return {void}

 tb.require class

 - add into prototype of your constructor
 - instance will get an &#x27;init&#x27; event when all files have loaded.

 @example

     tb.namespace( &#x27;app&#x27;, true ).GrandParent = (function(){

        // Constructor
        function GrandParent(){
            var that = this;

            that.handlers = {
                init,
                test
            };

        }

        // Prototype
        GrandParent.prototype = {

            namespace: &#x27;app.GrandParent&#x27;,

            &#x27;tb.Require&#x27;: [
                &#x27;/app/GrandParent.css&#x27;
            ]

        };

        return GrandParent;

        // Private Methods

        // ...

     })();
 
 */
tb.Require = function( pConfig ){

    var that = this;

    if ( !pConfig ) return;

    that.requirements = pConfig;

    // add requirement loading
    tb.loader.load(
        that.requirements,
        function(){
            that.target.trigger(&#x27;init&#x27;);
        }
    );

};

tb.Require.prototype = {
    ready: function(){
        // do we need this???
    }
};

/**
 * requirement handling
 */
(function(){
    // private

    function getTypeFromSrc( pSrc ){
        return pSrc.split(&#x27;?&#x27;)[0].split(&#x27;.&#x27;).pop();
    }

    // requirement constructor
    function _Requirement( pConfig ){

        var that = this,
            type = getTypeFromSrc( pConfig.src ), // filename extension
            typeConfigs = { // standard configuration types
                &#x27;css&#x27;: {
                    tag: &#x27;link&#x27;,
                    attributes: {
                        type: &#x27;text/css&#x27;,
                        rel: &#x27;stylesheet&#x27;,
                        href: &#x27;{src}&#x27;
                    }
                },
                &#x27;js&#x27;: {
                    tag: &#x27;script&#x27;,
                    attributes: {
                        type: &#x27;text/javascript&#x27;,
                        src: &#x27;{src}&#x27;
                    }
                }
            },
            typeConfig, // a single type configuration
            element,
            isTyped = !!typeConfigs[type];

        if ( !!tb.loader.requirementGroups[type][pConfig.src.split(&#x27;?&#x27;)[0]]
            &amp;&amp;  !!tb.loader.requirementGroups[type][pConfig.src.split(&#x27;?&#x27;)[0]].done ){ // already loaded

            that.trigger( &#x27;requirementLoaded&#x27;, src.split(&#x27;?&#x27;)[0], &#x27;u&#x27; );

            return;
        }

        pConfig.type = type; // add type

        that.config = pConfig;

        // cache busting
        if ( !!that.config.src ){
            that.config.src = that.config.src + ( that.config.src.indexOf( &#x27;?&#x27; ) &gt; -1 ? &#x27;&amp;&#x27; : &#x27;?&#x27; ) + tb.getId();
        }

        //that.target = pConfig.target;
        that.src = pConfig.src;
        that.type = that.config.type = type;
        that.done = false;
        that.cb = that.config.cb || function(){};
        that.data = tb.observable( {} );

        // element &#x27;load&#x27; callback
        function onLoad( e ){

            if ( !!e &amp;&amp; e.data ){
                that.data( e.data );
            }

            that.done = true;

            if ( that.type === &#x27;js&#x27; ) {
                setTimeout(
                    function(){
                        // that.element.parent.removeChild( that.element );     // remove js script tag from head
                    }
                    ,200
                );
            }

            that.trigger( &#x27;requirementLoaded&#x27;, that.src, &#x27;u&#x27; );

        }

        // execute onLoad only once
        onLoad.once = true;

        // handlers
        that.handlers = {
            &#x27;onLoad&#x27;: onLoad
        };


        if ( isTyped ) { // either *.css or *.js file

            // get default config for type
            typeConfig = typeConfigs[type];

            // create DOM element
            element = document.createElement( typeConfig.tag );
            element.async = true;
            element.onreadystatechange = element.onload = function() {
                var state = element.readyState;
                if (!that.done &amp;&amp; (!state || /loaded|complete/.test(state))) {
                    tb.status.loadCount( tb.status.loadCount() - 1 ); // decrease loadCount
                    that.trigger( &#x27;onLoad&#x27;, element );
                }
            };

            // add attributes to DOM element
            for ( var i in typeConfig.attributes ) if ( typeConfig.attributes.hasOwnProperty(i) ){
                element.setAttribute( i, tb.parse( typeConfig.attributes[i], that.config ) );
            }

            tb.status.loadCount( tb.status.loadCount() + 1 ); // increase loadCount

            // append node to head
            document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild( element );

            that.element = element;

        } else { // load via request if unknown type, trigger callback with text or JSON

            var f = function( data ){

                if ( that.type === &#x27;json&#x27; &amp;&amp; !!data[&#x27;text&#x27;] ){
                    try {
                        data = JSON.parse( data.text );
                    } catch( e ){
                        console.log( &#x27;error parsing, JSON expected in:&#x27;, data );
                    }
                } else {
                    data = data.text;
                }

                that.trigger( &#x27;onLoad&#x27;, data );
            };

            var options = {
                url: that.src,
                success: f,
                error: f
            };

            tb.request( options );

        }

    }

    _Requirement.prototype = {
        namespace: &#x27;_Requirement&#x27;
    };




    // requirement group constructor
    function _RequirementGroup( pConfig ){

        var that = this;

        that.type = pConfig.type;
        that.target = pConfig.target;

        that.requirements = {};

    };

    _RequirementGroup.prototype = {

        namespace: &#x27;_RequirementGroup&#x27;,

        load: function( pSrc ){

            var that = this,
                rq = !!that.requirements[ pSrc ];

            if ( !rq ){ // not loading or loaded: add a new requirement

                rq = that.requirements[ pSrc ] = new tb(
                    _Requirement,
                    {
                        src: pSrc,
                        target: that.target
                    },
                    that.requirements
                );

                that.requirements[ pSrc ].target = tb.loader; // needed for event bubbling

            } else { // already loading or loaded

                rq = that.requirements[ pSrc ];

            }

            if ( !!rq.done ){ // already loaded
                rq.trigger( &#x27;onLoad&#x27; );

            }

        }

    };




    function Loader( pConfig ){
        var that = this;

        that.config = pConfig;
        that.requirementGroups = {}; // will later contain requirement groups ( grouped by file extension )
        that.rqSets = []; // requirement sets, may contain various file types

        that.handlers = {
            requirementLoaded: requirementLoaded
        }
    };

    Loader.prototype = {

        namespace: &#x27;_Head&#x27;,

        load: function( pSrc, pCallback ){

            var that = this,
                pCallback = pCallback || function( e ){ console.log( &#x27;onLoad dummy handler on&#x27;, e ); },
                type,
                rg,
                groupCallback,
                pSrc = typeof pSrc === &#x27;string&#x27; ? [ pSrc ] : pSrc, // convert to array if string
                pSrc = ([]).concat( pSrc ); // make an array copy


            // will trigger loading if necessary ( async callback even if already loaded )
            pSrc
                .forEach(
                    function( filename ){
                        type = getTypeFromSrc( filename );
                        rg = !!that.requirementGroups[type];

                        if ( !rg ){ // add a new requirement group

                            that.requirementGroups[ type ] = new tb(
                                _RequirementGroup,
                                {
                                    type: type
                                },
                                that.requirementGroups
                            );

                            that.requirementGroups[ type ].target = tb.loader; // needed for event bubbling
                        }

                        rg = that.requirementGroups[ type ];

                        rg.load( filename );
                    }

                );

            pSrc.callback = pCallback;

            pSrc.done = function( pFilename ){ // will be called when each file &#x27;requirementLoaded&#x27; was triggered
                if ( pSrc.indexOf( pFilename ) &gt; -1 ){
                    pSrc.splice( pSrc.indexOf( pFilename ), 1 );
                }
            };

            that.rqSets.push( pSrc );

        },

        get: function( pFileName ){

            var that = this,
                type = getTypeFromSrc( pFileName),
                rg = that.requirementGroups[type] ? that.requirementGroups[type] : false,
                rq = rg ? ( rg.requirements[pFileName] ? rg.requirements[pFileName] : false ) : false;

            return rq ? rq.data() : &#x27;data missing for: &#x27; + pFileName;
        }

    };

    // bind _Head instance
    tb.loader = new tb( Loader );

    function requirementLoaded( e ){

        var that = this,
            filename  = e.data.split(&#x27;?&#x27;)[0];

        that
            .rqSets
            .forEach(
                function( pRqSet ){
                    pRqSet.done( filename );
                    if ( pRqSet.length === 0 ){ // every file loaded
                        pRqSet.callback();
                    }
                }
            );

        that.rqSets = that
            .rqSets
            .filter(
                function( pElement ){
                    return pElement.length &gt; 0;
                }
            );

        e.stopPropagation();
    }

})();


    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
