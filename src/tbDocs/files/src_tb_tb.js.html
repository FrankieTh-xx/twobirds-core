<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/tb/tb.js - twoBirds</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="twoBirds" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: v8.1.61</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/tb.html">tb</a></li>
                                <li><a href="../classes/tb.CRUD.html">tb.CRUD</a></li>
                                <li><a href="../classes/tb.dom.html">tb.dom</a></li>
                                <li><a href="../classes/tb.Event.html">tb.Event</a></li>
                                <li><a href="../classes/tb.Promise.html">tb.Promise</a></li>
                                <li><a href="../classes/tb.Require.html">tb.Require</a></li>
                                <li><a href="../classes/tb.Selector.html">tb.Selector</a></li>
                                <li><a href="../classes/tb.Util.html">tb.Util</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/tb/tb.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*! twobirds-core - v8.1.61 - 2018-06-23 */

/**
 twoBirds V8 core functionality

 @author          frank.thuerigen &lt;frank_thuerigen@yahoo.de&gt;
 @copyright       copyright (c) 2006- Frank Th√ºrigen
 @license         GNU LGPL v3 - read LICENSE.txt

 */

// temporary vars

// POLYFILLS

// matches polyfill
this.Element &amp;&amp; (function(ElementPrototype){
    ElementPrototype.matches = ElementPrototype.matches ||
        ElementPrototype.matchesSelector ||
        ElementPrototype.webkitMatchesSelector ||
        ElementPrototype.msMatchesSelector ||
        function(selector) {
            var node = this,
                nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;
            while (nodes[++i] &amp;&amp; nodes[i] !== node){}
            return !!nodes[i];
        };
})(Element.prototype); // jshint ignore:line

// closest polyfill
this.Element &amp;&amp; (function(ElementPrototype){
    ElementPrototype.closest = ElementPrototype.closest ||
        function(selector) {
            var el = this;
            while (el.matches &amp;&amp; !el.matches(selector)) {
                el = el.parentNode;
            }
            return el.matches ? el : null;
        };
})(Element.prototype); // jshint ignore:line

// twoBirds

tb = (function(){

    var internaltb;

    /**
     @class tb.Selector
     @constructor
     @extends tb

     @param {function|string|object|array} pSelector
     @param {domNode} [pDomNode] - optional, the DOM node in which to search 

     @returns {object} - the twoBirds instance you just created

     twoBirds selector constructor

     CAUTION: you may use this class directly if you know what you are doing,
     but the correct syntax for call is simply:

     @example

         tb( pSelector )
            .whateverChainedMethod(); // etc.

     HINT: tb() works as a selector, new tb() instanciates a twoBirds instance from a class.

     @example

         // get tB instances from DOM by css query selector
         tb( &#x27;div&#x27; )            // any tbInstance that sits in a div dom node

         // get tB instances from DOM by constructor
         tb( app.sampleConstructor )     // any tbInstance in DOM that is instanceof sampleConstructor

         // get tB instances from DOM by regEx
         tb( /myRegEx/ )    // any tbInstance in DOM that has a namespace property that fits the regEx

         // get tB instances from DOM by array of selectors
         tb( [ &#x27;body&#x27;, /myRegEx/ ] )     // any combination of selectors in an array, result is additive, flat and unique

     */
    function TbSelector( pSelector, pDomNode ){
        var that = this;

        that.length = 0;

        if ( !pSelector || pSelector instanceof tb.Selector ){
            return that;
        } else if( pSelector instanceof tb ){
            [].push.call( that, pSelector );
            return that;
        }

        switch (typeof pSelector) {

            // selection by dom selector string
            case &#x27;string&#x27;:
                
                tb.dom( pSelector+&#x27;[data-tb]&#x27;, pDomNode || document )
                    .forEach(
                        function ( pThisNode ) {
                            if ( !!pThisNode.tb ){
                                Object
                                    .keys( pThisNode.tb )
                                    .forEach(
                                        function( pKey ){
                                            [].push.call( that, pThisNode.tb[ pKey ] ); // push dom object to tb selector content
                                        }
                                    );
                            }
                        }
                    );
                break;

            case &#x27;object&#x27;:  // either regEx or nodeType

                if ( pSelector instanceof tb ){ // it is a twoBirds object

                    [].push.call( that, pSelector );
                    return that;

                }

                if ( pSelector instanceof RegExp ){ // it is a regular expression
                    tb.dom( &#x27;[data-tb]&#x27;, pDomNode || document )
                        .forEach(
                            function ( pDomNode ) {
                                Object
                                    .keys( pDomNode.tb )
                                    .forEach(
                                        function( pKey ){
                                            var tbElement = pDomNode.tb[ pKey ];

                                            if ( tbElement instanceof tb
                                                &amp;&amp; !!tbElement[&#x27;namespace&#x27;]
                                                &amp;&amp; !!tbElement.namespace.match( pSelector )
                                            ){
                                                [].push.call( that, tbElement );
                                            }
                                        }
                                    );
                            }
                        );

                } else if ( !!pSelector[&#x27;nodeType&#x27;] &amp;&amp; !!pSelector[&#x27;tb&#x27;] ){ // it is a dom node containing tb elements
                    Object
                        .keys( pSelector.tb )
                        .forEach(
                            function( pKey ){
                                [].push.call( that, pSelector.tb[ pKey ] );
                            }
                        );

                } else if ( pSelector.constructor === Array || !!pSelector[&#x27;length&#x27;]
                    &amp;&amp; !!pSelector[&#x27;0&#x27;] &amp;&amp; !(pSelector instanceof Array)
                ){
                    // it is an array || array like object
                    [].forEach.call(
                        pSelector,
                        function( pThisSelector ){
                            var thisResult = tb( pThisSelector );
                            [].forEach.call(
                                thisResult,
                                function( pTbElement ){
                                    if ( -1 === [].indexOf.call( that, pTbElement ) ){
                                        [].push.call( that, pTbElement );
                                    }
                                }
                            );
                        }
                    );
                }

                break;

            // selection by constructor: get all tb instances from DOM,
            // check whether their prototype matches constructor prototype
            case &#x27;function&#x27;:

                tb.dom( &#x27;[data-tb]&#x27;, pDomNode || document )
                    .map(
                        function ( pDomNode ) {
                            Object
                                .keys( pDomNode.tb )
                                .forEach(
                                    function( pKey ){
                                        var tbElement = pDomNode.tb[ pKey ];

                                        if ( !!tbElement
                                            &amp;&amp; tbElement instanceof tb
                                            &amp;&amp; tbElement instanceof pSelector
                                        ){
                                            [].push.call( that, tbElement );
                                        }
                                    }
                                );
                        }
                    );

                break;
        }

        return that;

    }

    // empty class def for temporary handler storage, needed for on(), one(), off() and trigger()
    function Nop(){}
    Nop.prototype = { namespace: &#x27;Nop&#x27; };

    // HINT: TbSelector (class) prototype definition after Tb prototype definition

    /**
     @class tb
     @constructor

     @param {object} pOptions
     @param pOptions.pClass - class Namespace as string or class
     @param [pOptions.pConfig] - optional configuration, any type, preferrably object
     @param [pOptions.pTarget] - target to put object in, DOM node or any other object

     @returns {object} - the twoBirds instance you just created

     twoBirds constructor

     @example

         // put Instance into DOM node
         new tb(
             app.myConstructor,                                     // any constructor you want to have an instance of
             { ... },                                               // the config object you hand over to the constructor
             target.appendChild( document.createElement( &#x27;span&#x27; ) ) // DOM node to insert the object item
         );

         // put Instance anywhere
         new tb(
             app.myConstructor,            // any constructor you want to have an instance of
             { ... },                      // the config object you hand over to the constructor
             anotherTbInstance             // any other object you want to put the tb instance in
         );

         // if a namespace STRING is given, requirement loading is done in case the class isnt present yet
         new tb(
             &#x27;app.myConstructor&#x27;,          // namespace string for the constructor you want to have an instance of
             { ... },                      // the config object you hand over to the constructor
             anotherTbInstance             // any other object you want to put the tb instance in
         );

     */
    function tb() {
        var that = this;

        // merge handlers from temp instance into target object
        function mergeHandlers( pSourceTb , pTargetTb ){
            for ( var i in pSourceTb.handlers ) {
                if ( !pTargetTb.handlers[i] ){
                    pTargetTb.handlers[i] = [];
                }
                for ( var j = 0, l = pSourceTb.handlers[i].length; j &lt; l; j++ ){
                    pTargetTb.handlers[i].push( pSourceTb.handlers[i][j] ); // copy handler
                }
            }
        }

        // instanciate tb instance OR return tb.Selector result set
        if ( that instanceof tb ) {    // called as constructor, create and return tb object instance
            var args = Array.from(arguments),
                isNamespace = typeof args[0] === &#x27;string&#x27;,
                isRootedNamespace = isNamespace &amp;&amp; args[0].substr(0,1) === &quot;/&quot;,
                fileName = isNamespace ? &#x27;/&#x27; + args[0].replace( /\./g, &#x27;/&#x27; ).replace( /^\//, &#x27;&#x27;) + &#x27;.js&#x27; : &#x27;&#x27;,
                tbClass =  isNamespace ? tb.namespace( args[0].replace( /^\//), &#x27;&#x27; ).get() : args[0],
                tbInstance,
                tempInstance; // empty tb object, used as handler store

            // namespace is a string and corresponding class doesnt exist in repo
            // -&gt; do requirement loading
            // -&gt; return temporary instance ( = instanceof Nop )
            if ( isNamespace &amp;&amp; !tbClass ){
                tempInstance = new tb( Nop, args[1] || {}, args[2] || false ); // construct temp tb instance from empty constructor -&gt; temp handler store

                tb.require(
                    fileName
                ).then(
                    (function( args ){          
                        return function(){

                            var thisTb = new tb(
                                args[0],
                                args[1] || {},
                                args[2] || false
                            );

                            if ( !!tempInstance ){

                                // copy properties from tempInstance, always shallow copy
                                for ( var i in tempInstance ) {
                                    if (
                                        ([&#x27;handlers&#x27;, &#x27;target&#x27;]).indexOf(i) === -1
                                        &amp;&amp; tempInstance.hasOwnProperty(i)
                                    ){
                                        thisTb[i] = tempInstance[i];
                                    }
                                }

                                mergeHandlers( tempInstance, thisTb );

                            }

                        };
                    })( args )
                );

                return tempInstance; // return temp instance so handlers can be attached
            }

            // it is a constructor call, like &quot;new tb(...)&quot;
            if ( typeof tbClass === &#x27;function&#x27; ){

                // prepare
                if ( !tbClass.__tb__ ){
                    Object.setPrototypeOf( tbClass.prototype, tb.prototype );
                    tbClass.__tb__ = &#x27;V8&#x27;;
                }

                // make a new instance of given constructor
                tbInstance = new tbClass( args[1] || {}, args[2] ); // hidden parameter target
                
                // prepare .namespace property of tb object
                if ( !tbInstance.namespace
                    &amp;&amp; !( tbInstance instanceof Nop )
                ){
                    tbInstance.namespace = typeof args[0] === &#x27;string&#x27;
                        ? args[0]
                        : args[0].namespace || tb.getId(); // if nothing helps, a unique id
                }

                // prepare .target property of tb object
                tbInstance.target = tbInstance[&#x27;target&#x27;] || args[2] || false; // preset
                
                // if target was not set in constructor, try third parameter
                if ( !tbInstance.target ){

                    if ( !!args[2] ){

                        // get first element of an array-like selector return object
                        if ( !args[2][&#x27;nodeType&#x27;]
                            &amp;&amp; !!args[2][0]
                            &amp;&amp; !!args[2][0][&#x27;nodeType&#x27;]
                        ){
                            args[2] = args[2][0]; // jshint ignore:line
                        }

                        tbInstance.target = args[2];
                    }

                }
                
                // if target is a DOM element
                // - add class to DOM data
                // - if not already there add namespace to target data-tb attribute
                if ( !!tbInstance.target
                    &amp;&amp; !!tbInstance.target[&#x27;nodeType&#x27;]
                    &amp;&amp; !( tbInstance instanceof Nop )
                ){

                    // put tb instance in dom node
                    tbInstance.target.tb = tbInstance.target[&#x27;tb&#x27;] || {};
                    tbInstance.target.tb[tbInstance.namespace] = tbInstance;

                    // if element does not reside in the DOM &lt;head&gt; add class
                    var dom = tb.dom( tbInstance.target );
                    if ( tbInstance.target.nodeName !== &#x27;head&#x27;
                        &amp;&amp; dom.parents().toArray().indexOf( document.head ) === -1
                        &amp;&amp; tbInstance.target.tagName.split(&#x27;&#x27;).indexOf(&#x27;-&#x27;) === -1
                        &amp;&amp; !!tbInstance[&#x27;namespace&#x27;]
                        &amp;&amp; tbInstance.namespace.replace(/\./g, &#x27;-&#x27;).toUpperCase() !== tbInstance.target.tagName
                    ){
                        dom.addClass( tbInstance.namespace.replace( /\./g, &#x27;-&#x27;).toLowerCase() );
                    }

                    // add namespace to DOM &quot;data-tb&quot; attribute
                    if ( !!tbInstance.target &amp;&amp; !!tbInstance.target[&#x27;nodeType&#x27;] ){
                        var dataTb = tbInstance.target.getAttribute( &#x27;data-tb&#x27; );
                        if ( !!dataTb &amp;&amp; !!dataTb.length &amp;&amp; -1 === dataTb.split(&#x27; &#x27;).indexOf( tbInstance.namespace ) ){
                            tbInstance.target.setAttribute( &#x27;data-tb&#x27;, dataTb + &#x27; &#x27; + tbInstance.namespace );
                        } else {
                            tbInstance.target.setAttribute( &#x27;data-tb&#x27;, tbInstance.namespace );
                        }
                    }
                }

                // create handlers array if necessary
                if ( !tbInstance.handlers ){
                    tbInstance.handlers = [];
                } else {
                    // if there are single named event handler functions,
                    // convert them to array of functions
                    for ( var i in tbInstance.handlers ) {
                        if ( typeof tbInstance.handlers[i] === &#x27;function&#x27; ){
                            tbInstance.handlers[i] = [ tbInstance.handlers[i] ];
                        } else if ( !( tbInstance.handlers[i] instanceof Array ) ){
                            delete tbInstance.handlers[i];
                        }
                    }
                }

                if ( !( tbInstance instanceof Nop ) ){

                    var parentReadyHandler = function(ev){
                        tbInstance
                            .parent()
                            .trigger(&#x27;ready&#x27;);
                    };

                    tbInstance.on( 
                        &#x27;ready&#x27;,
                        parentReadyHandler,
                        true
                    );

                    var parent = !!tbInstance.parent()[0] ? tbInstance.parent()[0] : false,
                        childReady = function(ev){
                            ev.stopImmediatePropagation();
                        };

                    childReady.once = true; 
                    
                    if ( parent ){
                        if ( !parent.handlers ){
                            parent.handlers = { ready: [] };
                        } else if ( !parent.handlers.ready ){
                            parent.handlers.ready = [];
                        }
                        parent.handlers.ready.unshift(childReady);
                    }

                    tbInstance.trigger( &#x27;init&#x27; );
                    tbInstance.trigger( &#x27;ready&#x27; );

                }

                return tbInstance;

            }

        } else { // arguments[0] is string or regex, return selector result

            return new TbSelector( 
                !!arguments[0] ? arguments[0] : undefined, 
                !!arguments[1] ? arguments[1] : undefined 
            );

        }

    }

    /**
     - takes any number of objects as parameters
     - merges content into the first parameter object
     - always a deep copy

     @memberof tb
     @static
     @method tb.extend

     @param {object} pObj - object to extend
     @param {...object} [pObj] any number of other objects to merge in

     @return {object} - extended object

     */
    tb.extend = function( pObj ){ // any number of arguments may be given
        var cp;

        function walk(pKey) {
            if ( cp.hasOwnProperty(pKey) &amp;&amp; 
                cp[pKey] instanceof Object &amp;&amp; 
                (cp[pKey]).constructor === Object 
            ){ // native Object
                pObj[pKey] = tb.extend( pObj[pKey] instanceof Object ? pObj[pKey] : {}, cp[pKey] ); // deep copy
            } else if ( cp.hasOwnProperty(pKey) &amp;&amp; 
                cp[pKey] instanceof Object &amp;&amp; 
                (cp[pKey]).constructor === Array 
            ){ // native Array
                pObj[pKey] = Array.from(cp[pKey]); // flat copy
            } else { // copy primitive or reference
                pObj[pKey] = cp[pKey];
            }
        }

        while ( arguments[1] ){
            cp = arguments[1];

            Object
                .keys(cp)
                .forEach(
                    walk
                );

            [].splice.call( arguments, 1, 1 ); // remove object that is done
        }

        return pObj;
    };

    /**

     - will replace all matching {namespace1.namespace2.etc} occurrences with values from pParse object
     - if typeof pWhat is object or array, it will be done with all strings contained therein and the original pWhat returned

     @memberof tb
     @static
     @method tb.parse
      
     @param {(string|object|array)} pWhat string, object or array to parse recursively
     @param {...object} pParse any number of hash objects containing replacement key/value pairs

     @return {(string|object|array)} pWhat parsed

     @example

         tb.parse( &quot;{a} test test&quot;, { a: &#x27;done&#x27; } )
         // &quot;done test test&quot;

     @example

         tb.parse( [ &quot;{a} test test&quot; ], { a: &#x27;done&#x27; } )
         // [&quot;done test test&quot;]

     @example

         tb.parse( [ &quot;{a} test test&quot;, &quot;{b} test test&quot; ], { a: &#x27;done&#x27;, b: &#x27;processed&#x27; } )
         // [&quot;done test test&quot;, &quot;processed test test&quot;]

     @example

         tb.parse( [ &quot;{a} test test&quot;, &quot;{b} test test&quot;, { g: &quot;another {silly} test&quot; } ], { a: &#x27;done&#x27;, b: &#x27;processed&#x27;, silly: &#x27;not so silly&#x27; } )
         // [&quot;done test test&quot;, &quot;processed test test&quot;, Object { g=&quot;another not so silly test&quot;}]

     @example

         tb.parse( { a: &quot;{a} test test&quot;, b: &quot;{b} test test&quot;, c: [ &quot;another {silly} test&quot; ] }, { a: &#x27;done&#x27;, b: &#x27;processed&#x27;, silly: &#x27;not so silly&#x27; } )
         // Object { a=&quot;done test test&quot;,  b=&quot;processed test test&quot;,  c=[ &quot;another not so silly test&quot; ] }

     @example

         // multiple hash objects:
         tb.parse(
            &quot;{a} {b}&quot;,
            { a: &#x27;done1&#x27; },
            { b: &#x27;done2&#x27; }
         );
         // &quot;done1 done2&quot;

     */
    tb.parse = function( pWhat, pParse ){
        var args = Array.prototype.slice.call(arguments);

        if (!args.length){
            console.error(&#x27;no arguments give to parse&#x27;);
            return;
        }

        if (args.length === 1){
            return args[1];
        } else if (args.length &gt; 2) {
            while (args.length &gt; 1){
                args[0] = tb.parse( args[0], args[1]);
                args.splice(1, 1);
            }
            return args[0];
        }

        // implicit else: exactly 2 arguments
        if ( typeof pWhat === &#x27;string&#x27; ){
            var vars = pWhat.match( /\{[^\{\}]*\}/g );

            if ( !!vars ) {
                vars
                    .forEach(
                        function (pPropname) {
                            var propname = pPropname.substr(1, pPropname.length - 2),
                                value = tb.namespace( propname, pParse ).get();

                            if ( typeof value !== &#x27;undefined&#x27; ){
                                pWhat = pWhat.replace( pPropname, value );
                            }
                        }
                    );
            }
        } else if ( !!pWhat.constructor ){
            switch ( pWhat.constructor ){
                case Object:
                    Object
                        .keys( pWhat )
                        .forEach(
                            function( pKey ){
                                if ( pWhat.hasOwnProperty( pKey ) ){
                                    pWhat[ pKey ] = tb.parse( pWhat[ pKey ], pParse );
                                }
                            }
                        );
                    break;
                case Array:
                    pWhat
                        .forEach(
                            function( pValue, pKey ){
                                pWhat[ pKey ] = tb.parse( pWhat[ pKey ], pParse );
                            }
                        );
                    break;
            }
        }

        return pWhat;
    };

    /**
     debounce function wrapper

     @memberof tb
     @static
     @method tb.debounce

     @param {function} pFunction - callback function to execute
     @param {number} pMilliseconds - milliseconds to wait before callback is executed

     @example
         // expect that to be this tb instance
         // append a debounced handler to the &#x27;myEvent&#x27; event
         that.on(
            &#x27;myEvent&#x27;, 
            tb.debounce(
                function(){
                    // that = tb instance
                    console.log(&#x27;debounced &quot;myEvent&quot; handler inside&#x27;, that);
                },
                500 // milliseconds
            )
         );
     */
    tb.debounce = function( pFunction, pMilliseconds ){
        var timeout;
        return function(){
            
            var that = this,
                args = arguments;

            clearTimeout( timeout );

            timeout = setTimeout(
                function(){
                    pFunction.apply( that, args );
                },
                pMilliseconds 
            );
        };
    };

    /**
     store function

     @memberof tb
     @static
     @method tb.store

     @param {object} pObj - object to put the store in
     @param {string} pName - property name of store
     @param {string} pConfig - the initial set of properties in a hash object

     @return {object} - the store instance

     the returned store has one method, .observe( myCallbackFunction )

     you can use this method to react on changes in the store

     CAVEAT: the store .observe is debounced to accomodate for bulk changes!

     @example
         
         //
         // EXAMPLE 1: using late binding
         //

         tb.store(
         
             that,   // the instance
             &#x27;store&#x27;,    // the property name -&gt; that.store
             $( &#x27;form&#x27;, that.target ).values()   // initial values
         
         ).bind( // assuming there are some {placeholder}s in that DOM node descendants attributes or text nodes

             that.target

         );

         // any change in the store from now on will update the {placeholder}s     

         // change complete store:
         that.store = { 
            somePlaceHolder: &#x27;someStringValue&#x27; 
         };

         // or a property within the store:
         that.store.somePlaceholder = &#x27;someOtherStringValue&#x27;;




         //
         // EXAMPLE 2: using the observe function
         // expect that to be a tbInstance containing a form
         //


         tb.store(
         
             that,   // the instance
             &#x27;store&#x27;,    // the property name -&gt; that.store
             $( &#x27;form&#x27;, that.target ).values()   // initial values
         
         ).observe(
             
             // 1 way data flow
             function( pStoreValues ){
                 
                 // do something with the store values
                 // e.g. update some part of the DOM

                 console.log( Object.assign( {}, pStoreValues ) );  // convert to plain object

                 // other than that you can extract properties like so:

                 var a = pStoreValues.myProperty;

             }
         
         );

         // update the store whenever the form values change
         // 2 way data binding
         
         $( &#x27;form&#x27;, that.target )
            on(
                &#x27;change select&#x27;,
                function(ev){
                    tb.extend( 
                        that.store, 
                        $( &#x27;form&#x27;, that.target ).values() 
                    ); 
                    ev.stopPropagation();
                }
            );

     */
    tb.store = (function(){

        function Store( pConfig ){

            var that = this,
                observable = Symbol(&#x27;observable&#x27;),
                onChange = Symbol(&#x27;onChange&#x27;),
                config = pConfig || {};

            // make anonymous property
            that[observable] = tb.observable(false);

            // must be debounced for looped property changes like
            // ... tb.extend( store, $(&#x27;form&#x27;).values() );
            that[onChange] = tb.debounce(
                function(){
                    that[observable]( tb.extend( {}, that ) );
                },
                0
            );

            tb.extend( that, config );

        }

        // these are prototypal methods, since the prototype is a Proxy instance
        Store.methods = {

            observe: function( pCallback, pOnce ){

                var that = this;

                that[Object.getOwnPropertySymbols(that)[0]].observe( pCallback, pOnce );

            },

            bind: function( pDomNode ){
                var that = this;
                
                function walk( pDomNode ){

                    if ( !!pDomNode[&#x27;nodeType&#x27;] &amp;&amp; pDomNode.nodeType === 3 ){ // text node
                        var placeholders = pDomNode.nodeValue.match( /\{[^\{\}]*\}/g );

                        if (!!placeholders){
                            
                            var f=(function( pTemplate ){
                                return function( pValues ){
                                    var t,
                                        changed = false;
                                    placeholders.forEach(function(pKey){
                                        if ( f.values[pKey] !== pValues[pKey] ){
                                            f.values[pKey] = pValues[pKey];
                                            changed = true;
                                        }
                                    });
                                    if (changed){ // only reflow if changed
                                        t = pTemplate;
                                        pDomNode.nodeValue = tb.parse(
                                            t,
                                            f.values
                                        );
                                    }
                                };
                            })( pDomNode.nodeValue );

                            f.values = {};
                            placeholders = Array.from( placeholders ).map((pKey) =&gt; pKey.substr(1,pKey.length-2)); 
                            placeholders.forEach(function(pKey){
                                f.values[pKey] = &quot;&quot;;
                            });
                            
                            that[Object.getOwnPropertySymbols(that)[0]].observe(f);

                        }
                    }

                    if ( !!pDomNode[&#x27;nodeType&#x27;] &amp;&amp; pDomNode.nodeType === 1 ){ // HTML element

                        Array.from( pDomNode.attributes )
                            .forEach(
                                function( pAttributeNode ){

                                    var placeholders = pAttributeNode.value.match( /\{[^\{\}]*\}/g );

                                    if (!!placeholders){

                                        var f=(function( pTemplate ){
                                            return function( pValues ){
                                                var t,
                                                    changed = false;
                                                placeholders.forEach(function(pKey){
                                                    if ( f.values[pKey] !== pValues[pKey] ){
                                                        f.values[pKey] = pValues[pKey];
                                                        changed = true;
                                                    }
                                                });
                                                if (changed){ // only reflow if changed
                                                    t = pTemplate;
                                                    tb.dom(pDomNode).attr(
                                                        pAttributeNode.nodeName,
                                                        tb.parse(
                                                            t,
                                                            f.values
                                                        )
                                                    );
                                                }
                                            };
                                        })( pAttributeNode.value );

                                        f.values = {};
                                        placeholders = Array.from( placeholders ).map((pKey) =&gt; pKey.substr(1,pKey.length-2)); 
                                        placeholders.forEach(function(pKey){
                                            f.values[pKey] = &quot;&quot;;
                                        });

                                        that[Object.getOwnPropertySymbols(that)[0]].observe(f);

                                    }
                                }
                            );

                        Array.from( pDomNode.childNodes )
                            .forEach(function( pChildNode ){
                                walk( pChildNode );
                            });

                        that[Object.getOwnPropertySymbols(that)[0]].notify();

                    }
                }

                walk( pDomNode );

            }

        };

        // prototype is a proxy
        Store.prototype = new Proxy(
            Store.methods, 
            {

                get: function(pObj, pProp, pReceiver) {
                    
                    if (Store.methods[pProp]){
                        return Store.methods[pProp];
                    }

                    if ( pProp in pReceiver === false &amp;&amp; pProp in pObj === false ){
                        
                        var value = new tb.Store();  // internal value

                        Object.defineProperty(
                            pReceiver,
                            pProp,
                            {
                                enumerable: true,
                                get: function(){
                                    return value;
                                },
                                set: function( pValue ){
                                    if ( !!pValue 
                                        &amp;&amp; typeof pValue === &#x27;object&#x27; 
                                        &amp;&amp; !!pValue.constructor 
                                        &amp;&amp; pValue.constructor === Object 
                                    ){
                                        if ( value instanceof Store ){
                                            for ( var key in value ){
                                                delete value[ key ];
                                            } 
                                            tb.extend( value, pValue );
                                        } else {
                                            value = new Store( pValue );
                                        }
                                    } else {
                                        value = pValue;
                                    }

                                    setTimeout(function(){
                                        if(!!Object.getOwnPropertySymbols(pReceiver)[1]){
                                            pReceiver[Object.getOwnPropertySymbols(pReceiver)[1]](); // onChange debounced function
                                        }
                                    }, 0);

                                    return value;
                                }
                            }
                        );                

                    }

                    return pReceiver[pProp];
                },

                set: function(pObj, pProp, pValue, pReceiver){

                    var ret,
                        args = Array.from(arguments);

                    if ( typeof pValue === &#x27;object&#x27; 
                        &amp;&amp; pValue.constructor === Object 
                        &amp;&amp; pValue.constructor.prototype === Object.prototype 
                    ){

                        if ( pReceiver[pProp] instanceof Store ){
                            for ( var key in pReceiver[pProp] ){
                                delete pReceiver[pProp][ key ];
                            } 
                            tb.extend( Store, pValue );
                        } else {
                            args[0] = pReceiver;
                            args[2] = new Store( pValue );
                        }
                        
                    }

                    setTimeout(function(){
                        if(!!Object.getOwnPropertySymbols(pReceiver)[1]){
                            pReceiver[Object.getOwnPropertySymbols(pReceiver)[1]](); // onChange debounced function
                        }
                    }, 0);

                    ret = Reflect.set(...args);

                    return ret;
                }

            }
        );

        tb.Store = Store;
        
        function makeStore( pObj, pName, pConfig ){

            var value = new Store( pConfig );

            // insert store into target object
            Object.defineProperty(
                pObj,
                pName,
                {
                    enumerable: true,
                    writeable: true,
                    get: function(){
                        return value;
                    },
                    set: function( pValue ){
                        for ( var key in value ){
                            delete value[ key ];
                        } 
                        tb.extend( value, pValue );
                        return value;
                    }
                }
            );

            return pObj[pName];
        }

        makeStore.Store = Store;

        return makeStore;

    })();

    /**
     tb.observable()) function
     - creates a function to set/get the inner value
     - initializes the inner value with the parameter given
     - returns this function

     @memberof tb
     @static
     @method tb.observable
     @chainable

     @param {*} [pStartValue] initial content of observable

     @return {function} - observableFunction

     @example

         // observable data IS NOT an object
         var o = tb.observable( 0 );                // numeric

         o.observe(
             function( pValue ){                    // callback will be triggered when observable value changes
                 console.log( pValue );
             },
             true                                   // true indicates callback will be called only once
         );

         o( 5 );                                    // change observable value

     @example

         // observable data IS an object
         var o = tb.observable( { a: 5 } );         // object

         o.observe(
             function( pValue ){                    // callback will be triggered when observable value changes
                         console.log( pValue );
                     },
             false                                  // false or no parameter indicates callback will always be called
                                                    // when the data changes, true will trigger it only once
         );

         // get data:
         o( &#x27;a&#x27; );       // =&gt; 5
         o();            // =&gt; { a: 5 }

         // each of these will trigger the callback since the data changed
         // also they return the observable itself for chaining purposes, NOT THE VALUE
         o( &#x27;a&#x27;, 6 );               // =&gt; { a: 6 }
         o( { c: 42 } );            // =&gt; { c: 42 }
         o( &#x27;b&#x27;, { c: 42 } );       // =&gt; { a: 6, b: { c: 42 } }


     */
    tb.observable = function( pStartValue ){

        var observedValue = pStartValue,
            enableNotify = true;

        // make observable function to return in the end
        var observableFunction = function( p1, p2 ){

            function notify(){
                if ( !enableNotify ) {
                    return;
                }
                observableFunction.lastChanged = (new Date()).getTime(); // needed for tb.idle()
                return observableFunction.notify();
            }

            if ( typeof p1 !== &#x27;undefined&#x27; ){
                if( observedValue.constructor === Object ) {
                    if ( typeof p1 === &#x27;string&#x27; ) {
                        if (typeof p2 !== &#x27;undefined&#x27;) {
                            // value has changed, p1 must be key or namespace ( key1.key2 etc ) for object property
                            if ( p1.indexOf(&#x27;.&#x27;) &gt; -1 ){ // its a namespace
                                tb.namespace( p1, observedValue ).set( p2 );
                            } else { // it is a simple property
                                observedValue[p1] = p2;
                            }
                            notify();
                        } else {    // it is a getter
                            return tb.namespace( p1, observedValue ).get();
                        }
                    } else if ( typeof p1 === &#x27;object&#x27; &amp;&amp; typeof p2 === &#x27;undefined&#x27; ){
                        observedValue = p1;
                        notify();
                    } else {
                        console.warn(&#x27;tb.observable() set value: parameter 1 should be a string or object if observed data is an object!&#x27;);
                    }
                } else {
                    if ( typeof p1 !== &#x27;undefined&#x27; ){
                        // value has changed
                        observedValue = p1;
                        notify();
                    } else {    // it is a getter
                        return observedValue;
                    }
                }
            } else {
                return observedValue;
            }

            // it was a setter functionality, so return the observable itself for chaining
            // getters return the value directly (see above)
            return observableFunction;
        };

        observableFunction.lastChanged = (new Date()).getTime(); // needed for tb.idle()

        // list of all callbacks to trigger on observedValue change
        observableFunction.notifiers = [];

        // function used to execute all callbacks
        observableFunction.notify = function(){

            // execute all callbacks
            observableFunction.notifiers.forEach(
                function( func, key ){
                    if ( typeof func === &#x27;function&#x27; ){
                        func( observedValue );
                        if ( func.once ){
                            observableFunction.notifiers.splice(key,1);
                        }
                    } else {
                        observableFunction.notifiers.splice(key,1);
                    }
                }
            );

            return observableFunction; // chaining
        };

        // enable/disable notifications
        observableFunction.enableNotify = function( pEnableNotify ){
            enableNotify = pEnableNotify === false ? false : true;

            return observableFunction; // chaining
        };

        // function used to add a callbacks
        observableFunction.observe = function( pFunction, pOnce ){

            if ( typeof pFunction === &#x27;function&#x27; ){
                pFunction.once = pOnce || false;
                observableFunction.notifiers.push( pFunction );
            }

            return observableFunction; // chaining
        };

        return observableFunction;
    };

    internaltb = tb;

    tb.Selector = TbSelector; // make official, e.g. for events

    /**
      walk all pSelector tb objects, call pMethodName on them
      return a UNIQUE TbSelector result set containing all single results

      @function walkSelector
      @private

      @param {object} pSelectorObject - instanceOf TbSelector
      @param {string} pMethodName - name of method to call
      @param {*} [pArguments] - arguments

      @return {object} instance of TbSelector
     */
    function walkSelector( pSelectorObject, pMethodName, pArguments ){
        var that = this,
            instances = Array.from( pSelectorObject ),
            args = Array.from( pArguments ),
            ret = tb(); // empty tb selector object

        //console.log(&#x27;pSelectorObject&#x27;, pSelectorObject);
        if ( pSelectorObject instanceof TbSelector ) {
            //console.log(&#x27;-&gt; Array&#x27;, Array.from(pSelectorObject) );
            instances
                .forEach( function walkSelectorEach( pInstance ) {
                    var result = pInstance[pMethodName]( ...args );
                    if ( result instanceof TbSelector ) {
                        Array
                            .from(result)
                            .forEach(function(pResultInstance){
                                if ( [].indexOf.call( ret, pResultInstance ) === -1 ){
                                    [].push.call( ret, pResultInstance );
                                }
                            });
                    }
                });

        }
        //console.log(&#x27;&lt;- result&#x27;, Array.from(ret) );
        return ret;
    }

    function _mapArrayMethod( pMethodName ){
        var method = [][pMethodName];

        if ( -1 &lt; ([ &#x27;pop&#x27;, &#x27;push&#x27;, &#x27;unshift&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27; ]).indexOf( pMethodName ) ){ // self-muting methods
            return function(){
                var that = this,
                    ret = method.apply( that, arguments );

                return !!ret ? ( ret instanceof Array ? tb( ret ) : ret ) : that;
            };
        } else {
            return function(){
                var that = this,
                    ret = method.apply( that.toArray(), arguments );

                if ( ret instanceof Array ){
                    return that.flush().add( ret );
                }

                return ret;
            };
        }

    }

    tb.methods = (function(){
        // private static

        return {
            // public methods and properties

            /**
              @method trigger
              @chainable

              @param {string} pEvent - name of event OR tb.Event instance (in this case the only parameter)
              @param [pEventData] - event data, usally an object
              @param {string} [pBubble=l] - bubbling indicator : &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down - or any combination

              @return {object} - tb.Selector instance or tB instance - for chaining

              trigger method

              triggers an asynchronous twoBirds event, optionally with data and bubble indicator

             */
            trigger: function( pEvent, pEventData, pBubble ){
                var that = this,
                    tbEvent;

                if( tb.stop() ){ // @todo rethink this
                    return;
                }

                // construct event if necessary
                tbEvent = pEvent instanceof tb.Event ? pEvent : new tb.Event( pEvent, pEventData, pBubble );

                // if event __stopped__ , handling is cancelled
                if ( tbEvent.__stopped__ || tbEvent.__immediateStopped__ ) {
                    return that;
                }

                // execute local handlers
                if ( that instanceof TbSelector &amp;&amp; !!that[&#x27;length&#x27;] ) {

                    [].forEach.call(
                        that,
                        function( tbInstance ){
                            if ( !!tbInstance
                                &amp;&amp; tbInstance instanceof tb
                                &amp;&amp; !tbEvent.__immediateStopped__
                            ){
                                tbInstance.trigger( tbEvent );
                            }
                        }
                    );

                } else if ( that instanceof tb ) { // it must be a native tb object

                    if ( that instanceof Nop
                        &amp;&amp; tbEvent.name !== &#x27;init&#x27;
                    ){
                        // its an object that was not loaded yet
                        that.one(
                            &#x27;init&#x27;,
                            function lazyHandler(){
                                var that = this;

                                that.trigger( tbEvent );
                            }
                        );
                        return that;
                    }

                    // local handlers
                    if ( that instanceof tb 
                        &amp;&amp; !!that.handlers 
                        &amp;&amp; !!that.handlers[tbEvent.name] 
                        &amp;&amp; tbEvent.bubble.indexOf( &#x27;l&#x27; ) &gt; -1 
                    ){

                        that.handlers[tbEvent.name] = [].reduce.call( that.handlers[tbEvent.name],
                            function( pHandlers, pHandler ){
                                if ( tbEvent.bubble.indexOf(&#x27;l&#x27;) &gt; -1
                                    &amp;&amp; !!pHandler
                                ){
                                    try{
                                        if (!tbEvent.__immediateStopped__){
                                            pHandler.apply(that, [tbEvent]);
                                        } else {
                                            pHandlers.push( pHandler );
                                        }
                                    } catch (e){
                                        console.error(e);
                                    }

                                    if ( !pHandler.once &amp;&amp; !tbEvent.__immediateStopped__ ) {
                                        pHandlers.push( pHandler );
                                    }                                }
                                return pHandlers;
                            }, []);

                            if (!that.handlers[tbEvent.name].length){
                                delete that.handlers[tbEvent.name];
                            }
                    }

                    // if event __stopped__ , handling is cancelled
                    if ( !!tbEvent.__stopped__  ) {
                        return that;
                    }

                    setTimeout(
                        function(){

                            // bubble up
                            if ( tbEvent.bubble.indexOf(&#x27;u&#x27;) &gt; -1 ){
                                that
                                    .parent()
                                    .trigger(
                                        new tb.Event(
                                            tbEvent.name,
                                            tbEvent.data,
                                            &#x27;lu&#x27;
                                        ));
                            }

                            // bubble down
                            if ( tbEvent.bubble.indexOf(&#x27;d&#x27;) &gt; -1 ){
                                [].forEach.call(
                                    that.children(),
                                    function( tbObject ){
                                        tbObject.trigger(
                                            new tb.Event(
                                                tbEvent.name,
                                                tbEvent.data,
                                                &#x27;ld&#x27;
                                            )
                                        );
                                    }
                                );
                            }

                        },
                        0
                    );

                }

                return that;

            },

            /**
             @method on
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array
             @param {boolean} [pOnce=false] - true = remove handler after first call, false = keep handler

             @return {object} - tb.Selector instance or tB instance - for chaining

             .on() method

             adds a handler to a twoBirds instance or a tb.Selector result set
             */
            on: function( pEventName, pHandler, pOnce ){

                var that = this,
                    eventNames;

                //console.log( &#x27;on&#x27;, pEventName, pHandler, pOnce );

                if ( that instanceof TbSelector ) {

                    walkSelector( that, &#x27;on&#x27;, Array.from(arguments) );

                } else if ( that instanceof tb ) { // either a toplevel or an internal tb object

                    if ( -1 &lt; pEventName.indexOf(&#x27; &#x27;) ){
                        eventNames = pEventName.split(&#x27; &#x27;);
                    } else {
                        eventNames = [ pEventName ];
                    }
                    pHandler.once = !!pHandler.once || !!pOnce;

                    eventNames.forEach(
                        function(pThisEventName){

                            if ( !Reflect.get( that, &#x27;handlers&#x27; ) ){
                                that.handlers = {};
                            }

                            if ( that.handlers[ pThisEventName ] instanceof Array === false ){
                                that.handlers[ pThisEventName ] = [];
                            }

                            [].push.call( that.handlers[ pThisEventName ], pHandler );

                        }
                    );

                }

                return that;

            },

            /**
             @method one
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array

             @return {object} - tb.Selector instance or tB instance - for chaining

             .one() method

             adds a handler to a twoBirds instance or a tb.Selector result set,
             to be called only once when the event fires
             afterwards the handler is deleted from the event handler list
             */
            one: function( pEventName, pHandler ){

                var that = this;

                that.on( pEventName, pHandler, true ); // add event handler that will be deleted after first execution

                return that;

            },

            /**
             @method off
             @chainable

             @param {string} pEventName - name of the handler function
             @param {function} pHandler - the function to be added to the handler array

             @return {object} - tb.Selector instance or tB instance - for chaining

             .off() method

             removes a handler from a twoBirds instance or a tb.Selector result set
             afterwards the handler is deleted from the event handler list
             */
            off: function( pEventName, pHandler ){

                var that = this,
                    index,
                    eventNames;

                if ( typeof pEventName === &#x27;undefined&#x27; ){
                    return that;
                }

                if ( that instanceof TbSelector ) {

                    walkSelector( that, &#x27;off&#x27;, arguments );

                } else if ( that instanceof tb ) { // either a toplevel or an internal tb object

                    if ( -1 &lt; pEventName.indexOf(&#x27; &#x27;) ){
                        eventNames = pEventName.split(&#x27; &#x27;);
                    } else {
                        eventNames = [ pEventName ];
                    }

                    //console.log( &#x27;off&#x27;, that instanceof tb, that, eventNames, pHandler );

                    eventNames
                        .forEach(

                            function(pThisEventName){

                                if ( !!that.handlers[ pThisEventName ] ){
                                    if ( typeof pHandler !== &#x27;undefined&#x27; ){
                                        index = that.handlers[ pThisEventName ].indexOf( pHandler );

                                        while ( index &gt; -1 ){
                                            that.handlers[ pThisEventName ].splice( index, 1 );

                                            index = that.handlers[ pThisEventName ].indexOf( pHandler );

                                            if ( that.handlers[ pThisEventName ].length === 0 ){ // remove array if empty
                                                that.handlers[ pThisEventName ] = null;
                                                delete that.handlers[ pThisEventName ];
                                            }

                                        }
                                    } else { // remove all handlers
                                        that.handlers[ pThisEventName ] = null;
                                        delete that.handlers[ pThisEventName ];
                                    }
                                }
                            }
                        );

                }

                return that;

            },

            /**
             @method parents
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .parents() method

             for each this[0...n] or this as tb() instance,
             - get all parent tb objects
             - check them against the filter param pSelector
             - return them as a TbSelector result set (unique)
             */
            parents: function( pSelector ){
                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parents&#x27;, arguments );

                } else if ( that instanceof tb
                    &amp;&amp; !!that.target
                ){ // it is a tb object

                    if ( !!that.target[&#x27;nodeType&#x27;] ){
                        // it must be a native toplevel tb object residing in the DOM
                        tb.dom( that.target )
                            .parents( &#x27;[data-tb]&#x27; )
                            .not( &#x27;html&#x27; )
                            .forEach(
                                function( pElement ){
                                    if ( !!pElement &amp;&amp; !!pElement[&#x27;tb&#x27;] ){
                                        Object
                                            .keys( pElement.tb )
                                            .forEach(
                                                function( pKey ){
                                                    // push dom object to tb selector content
                                                    [].push.call( ret, pElement.tb[pKey] );
                                                }
                                            );
                                    }
                                }
                            );

                    } else if ( that.target instanceof tb ){
                        // it a tb object embedded in another tb object

                        [].push.call( ret, that.target ); // push parent object to tb selector content

                        if ( !!that.target.parent()[&#x27;0&#x27;] ){
                            [].push.call( ret, that.target.parent()[&#x27;0&#x27;] );
                        }

                    }


                }

                return pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method parent
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .parent() method

             for each this[0...n] or this as tb() instance,
             - get closest parent tb object
             - check all of them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            parent: function( pSelector ){

                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;parent&#x27;, arguments );

                } else if ( that instanceof tb
                    &amp;&amp; !!that.target
                ){

                    if ( !!that.target[&#x27;nodeType&#x27;] ) { // tb object resides in DOM

                        var tbParents = that.parents().toArray(),
                            tbParent = !!tbParents[&#x27;0&#x27;] ? tbParents[0] : false;

                        if ( !tbParent ) {
                            return ret;
                        } // no parent -&gt; empty result set

                        Object
                            .keys(tbParent.target.tb || {})
                            .forEach(function( pKey ){
                                [].push.call( ret, tbParent.target.tb[pKey] ); // push dom object to tb selector content
                            });

                    } else if ( that.target instanceof tb ){ // it is an embedded object, local target is another (parent) tb object

                        [].push.call( ret, that.target ); // push parent object to tb selector content

                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method descendants
             @chainable

             @param [pSelector] - any type of tb.Selector parameter

             @return {object} - tb.Selector instance - for chaining

             .descendants() method

             for each this[0...n] or this as tb() instance,
             - get all descendants of tb object
             - check them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            descendants: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb();

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;descendants&#x27;, arguments );

                } else if ( that instanceof tb &amp;&amp; !!that.target[&#x27;nodeType&#x27;] &amp;&amp; !pLocalOnly ) { // it must be a native tb object

                    tb.dom( &#x27;[data-tb]&#x27;, that.target )
                        .forEach(
                            function( pDomNode ) {
                                Object
                                    .keys( pDomNode.tb )
                                    .forEach(function( pKey ){
                                        [].push.call( ret, pDomNode.tb[ pKey ] ); // push dom object to tb selector content
                                    });
                            }
                        );

                } else if ( that instanceof tb &amp;&amp; !!pLocalOnly ){ // walk descendants
                    // HINT: if tbInstances are stacked inside each other, only props in &quot;this&quot; will be copied
                    //       ...not those defined in the constructor.prototype ( like &#x27;tb.Require&#x27; )
                    Object
                        .keys( that )
                        .forEach(function( pKey ){
                            if ( pKey !== &#x27;target&#x27; &amp;&amp; that[pKey] instanceof tb ) {
                                [].push.call( ret, that[pKey]); // push tb object to tb selector content

                                var desc = tb.dom().toArray.call( that[pKey].descendants( &#x27;&#x27;, true ) );

                                for ( var j=0, l=desc.length; j&lt;l; j++ ){
                                    [].push.call( ret, desc[j]); // push tb object to tb selector content
                                }
                            }
                        });
                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method children
             @chainable

             @param [pSelector] - any type of tb.Selector parameter
             @param {boolean} [pLocalOnly] - only local children of given tb instance(s)

             @return {object} - tb.Selector instance - for chaining

             .children() method

             for each this[0...n] or this as tb() instance,
             - get all direct children of tb object
             - check them against the filter param pSelector
             - return TbSelector result set (unique)
             */
            children: function( pSelector, pLocalOnly ){

                var that = this,
                    ret = tb(),
                    args =  Array.from(arguments),
                    pLocalOnly = typeof module !== &#x27;undefined&#x27; ? true : pLocalOnly; // jshint ignore:line

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( that, &#x27;children&#x27;, args );

                } else if ( that instanceof tb 
                    &amp;&amp; !!that.target[&#x27;nodeType&#x27;] 
                    &amp;&amp; !pLocalOnly 
                ){ // it must be a native tb object
                    var id = tb.getId(),
                        selector = tb.dom(&#x27;[data-tb]&#x27;, that.target),
                        notSelector = &#x27;[data-tempid=&quot;&#x27;+id+&#x27;&quot;] [data-tb] [data-tb]&#x27;;

                    // set temporary id for tb.dom/.querySelectorAll()
                    tb.dom( that.target )
                        .attr( &#x27;data-tempid&#x27;, id );

                    selector // all descendants
                        .not( notSelector ) // but not those that are below level 1
                        .forEach(
                            function( pDomNode, pIndex, pList ) {
                                if ( !!pDomNode[&#x27;tb&#x27;] ){
                                    Object
                                        .keys( pDomNode.tb )
                                        .forEach(function( pKey ){
                                            [].push.call( ret, pDomNode.tb[ pKey ] ); // push dom object to tb selector content
                                        });
                                }
                            }
                        );

                    // remove temporary id
                    tb.dom( that.target )
                        .removeAttr( &#x27;data-tempid&#x27; );

                } else if ( !!pLocalOnly ){

                    for ( var i in that ){
                        if ( that.hasOwnProperty(i) &amp;&amp; that[i] instanceof tb ){
                            [].push.call( ret, that[i] ); // push tb object to tb selector content
                        }
                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method next
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             next() method

             for each this[0...n] or this as tb() instance,
             - get the direct following sibling of tb instance
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            next: function( pSelector ){

                var that = this,
                    ret = tb(), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;next&#x27;, arguments );

                } else { // it must be a native tb object

                    result = that.parent().children();
                    index = [].indexOf.call( result, that );

                    if ( result.length &gt; index + 1 ) {
                        [].push.call( ret, result[ index + 1 ] ); // push dom object to tb selector content
                    }

                }
                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method prev
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             prev() method

             for each this[0...n] or this as tb() instance,
             - get the direct previous sibling of tb instance
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            prev: function( pSelector ){

                var that = this,
                    ret = tb(), // empty tb selector object
                    result,
                    index;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;prev&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    index = [].indexOf.call( result, this );

                    if ( index ) {
                        [].push.call( ret, result[ index - 1 ] ); // push dom object to tb selector content
                    }

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method first
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             first() method

             for each this[0...n] or this as tb() instance,
             - get the first child of the tb object parent
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            first: function( pSelector ){

                var that = this,
                    ret = tb(),
                    result;

                if ( that instanceof TbSelector ) {

                    ret = walkSelector( this, &#x27;first&#x27;, arguments );

                } else { // it must be a native tb object

                    result = this.parent().children();
                    [].push.call( ret, result[ 0 ] ); // push dom object to tb selector content

                }

                return !!pSelector ? ret.filter( pSelector ) : ret;

            },

            /**
             @method last
             @chainable

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             last() method

             for each this[0...n] or this as tb() instance,
             - get the last child of the tb object parent
             - check it against the filter param pSelector
             - return TbSelector result set (unique)
             */
            last: function( pSelector ){
                var that = this,
                    ret = tb(),
                    result;

                if ( that instanceof TbSelector ) {
                    ret = walkSelector( this, &#x27;last&#x27;, arguments );
                } else {
                    result = this.parent().children();
                    [].push.call( ret, result[ result.length - 1 ] ); // push dom object to tb selector content
                }
                return !!pSelector ? ret.filter( pSelector ) : ret;
            },

            /**
             @method toArray

             @return {array} - TbSelector elements in a plain array

             toArray() method
             */
            toArray: function(){
                var that = this;

                return Array.from( that );
            },

            /**
             @method filter
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             filter() method

             for each this[0...n] or this as tb() instance,
             - check them against the filter param pParam
             - return TbSelector result set (unique)
             */
            filter: function( pSelector ){

                var that = this,
                    compare = tb( pSelector ), // object array to check against
                    ret = tb();

                if ( !pSelector ) {
                    return that;
                }

                if ( that instanceof TbSelector ) {
                    [].forEach.call(
                        that,
                        function( tbObject ) {
                            if ( -1 &lt; [].indexOf.call( compare, tbObject ) ){
                                [].push.call( ret, tbObject );
                            }
                        }
                    );
                } else if ( that instanceof tb ){
                    if ( -1 &lt; [].indexOf.call( compare, that ) ){
                        [].push.call( ret, that );
                    }
                }

                return ret;
            },

            /**
             @method not
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             not() method

             for each this[0...n] or this as tb() instance,
             - check them against pSelector and remove all that match
             - return TbSelector result set (unique)
             */
            &#x27;not&#x27;: function( pSelector ){

                var that = this,
                    compare = Array.from( tb( pSelector ) ), // object array to check against
                    ret = tb();

                [].forEach.call(
                    that,
                    function( pTbInstance ) {
                        if ( compare.indexOf( pTbInstance ) === -1 ){
                            [].push.call( ret, pTbInstance );
                        }

                    }
                );

                return ret;
            },

            /**
             @method add
             @chainable

             @param [pParam] - any kind of TbSelector parameter

             @return {object} - tb.Selector instance (maybe empty) - for chaining

             add() method

             add elements to current result set
             - return TbSelector result set (unique)
             */
            add: function( pSelector ){

                var that = this,
                    add = tb( pSelector ).toArray(), // object array to check against
                    ret = that.toArray();

                return tb( ret.concat( add ) );
            },

            /**
             @method flush
             @chainable

             @return {object} - mpty tb.Selector instance - for chaining

             flush() method

             empty current result set
             - return empty TbSelector result set
             */
            flush: function(){

                var that = this;

                if ( that instanceof TbSelector ){
                    while ( that.length ){
                        that.pop();
                    }
                }
                return that;
            }

        };

    })();

    var proxy = new Proxy(
        tb.Store.methods, 
        {

            get: function(pObj, pProp, pReceiver) {
                
                var args = Array.from(arguments);

                //console.log( &#x27;tb.get&#x27;, ...args );

                if ( !Reflect.get( ...args ) ){
                    
                    var value = new tb.Store();  // internal value
                    
                    Object.defineProperty(
                        pReceiver,
                        pProp,
                        {
                            enumerable: true,
                            get: function(){
                                return value;
                            },
                            set: function( pValue ){
                                if ( typeof pValue === &#x27;object&#x27; &amp;&amp; pValue.__proto__ === Object.prototype ){ // jshint ignore:line
                                    if ( value instanceof tb.Store ){
                                        for ( var key in value ){
                                            delete value[ key ];
                                        } 
                                        tb.extend( value, pValue );
                                    } else {
                                        value = new tb.Store( pValue );
                                    }
                                } else {
                                    value = pValue;
                                }

                                setTimeout(function(){
                                    if(!!Object.getOwnPropertySymbols(pReceiver)[1]){
                                        pReceiver[Object.getOwnPropertySymbols(pReceiver)[1]](); // onChange debounced function
                                    }
                                }, 0);

                                return value;
                            }
                        }
                    );                

                }

                return Reflect.get( ...args );
            },

            set: function(pObj, pProp, pValue, pReceiver){

                var ret,
                    args = Array.from(arguments);

                //console.log( &#x27;tb.set&#x27;, ...args );

                if ( pProp !== &#x27;handlers&#x27; &amp;&amp; typeof pValue === &#x27;object&#x27; ){

                    if ( pReceiver[pProp] instanceof tb.Store &amp;&amp; pValue.__proto__ === Object.prototype ){ // jshint ignore:line
                        for ( var key in pReceiver[pProp] ){
                            delete pReceiver[pProp][ key ];
                        } 
                        tb.extend( pReceiver[pProp], pValue );
                    } else {
                        args[0] = pReceiver;
                        //args[2] = new tb.Store( pValue );
                    }
                    
                }

                ret = Reflect.set(...args);

                setTimeout(function(){
                    if(!!Object.getOwnPropertySymbols(pReceiver)[1]){
                        pReceiver[Object.getOwnPropertySymbols(pReceiver)[1]](); // onChange debounced function
                    }
                },0);

                return ret;
            }

        }
    );

    Object.setPrototypeOf( tb.methods, proxy );
                    
    //console.log(&#x27;methods&#x27;, methods);
    //console.log(&#x27;proxy&#x27;, proxy);
    tb.prototype = tb.methods;
    //console.log(&#x27;tb.prototype&#x27;, tb.prototype);

    /**
     @memberof tb
     @static
     @property tb.status
     @type Object

     container for twoBirds status observables
     */
    tb.status = {
        /**
         @property tb.status.loadCount
         @type Function

         observable containing the number of ( script load operations + xHr requests ) currently pending
         */
        loadCount: tb.observable(0)         // contains the number of ( file loads + xHr requests ) pending
    };

    /**
     @memberof tb
     @static
     @method tb.idle

     @param {function} pCallback function to execute when all loading is finished

     @example

        // in code...
        tb.idle(
            function(){
                // do whatever you like
            }
        );
     */
    tb.idle = function( pCallback ){

        var f = function(){

            if ( tb.status.loadCount() === 0 ){

                var tf = function(){

                    if ( tb.status.loadCount() === 0 ){ // loadCount is (still) 0
                        if (
                            tb.status.loadCount.lastChanged === tf.lastChanged // it is still the previous &#x27;0&#x27; loadcount
                        ){
                            // system is still idle
                            if ( typeof pCallback === &#x27;function&#x27;){
                                pCallback();
                            }
                        } else {
                            // probably not idle -&gt; retry in 50 ms
                            tf.lastChanged = tb.status.loadCount.lastChanged;
                            setTimeout(
                                tf,
                                100
                            );
                        }
                    } else { // loadCount is not 0 -&gt; reattach function
                        tb.status.loadCount.observe( f, true );
                    }
                };

                tf.lastChanged = 0;

                setTimeout(
                    tf,
                    100
                );
            } else {
                // if idle not yet reached, re-attach function for ONE execution
                tb.status.loadCount.observe( f, true );
            }

        };

        // attach function for ONE execution
        tb.status.loadCount.observe( f, true );

    };

    TbSelector.prototype = {
        /**
         @method concat
         @chainable

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat&quot;&gt;concat&lt;/a&gt;
         */
        concat: _mapArrayMethod( &#x27;concat&#x27; ),

        /**
         @method every
         @chainable

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;every&lt;/a&gt;
         */
        every: _mapArrayMethod( &#x27;every&#x27; ),

        /**
         @method forEach
         @chainable

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;forEach&lt;/a&gt;
         */
        forEach: _mapArrayMethod( &#x27;forEach&#x27; ),

        /**
         @method indexOf

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;indexOf&lt;/a&gt;
         */
        indexOf: _mapArrayMethod( &#x27;indexOf&#x27; ),

        /**
         @method map

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;map&lt;/a&gt;
         */
        map: _mapArrayMethod( &#x27;map&#x27; ),

        /**
         @method pop

         @return {object} - tb instance

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop&quot;&gt;pop&lt;/a&gt;
         */
        pop: _mapArrayMethod( &#x27;pop&#x27; ),

        /**
         @method push

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push&quot;&gt;push&lt;/a&gt;
         */
        push: _mapArrayMethod( &#x27;push&#x27; ),

        /**
         @method reduce

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;reduce&lt;/a&gt;
         */
        reduce: _mapArrayMethod( &#x27;reduce&#x27; ),

        /**
         @method reduceRight

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight&quot;&gt;reduceRight&lt;/a&gt;
         */
        reduceRight: _mapArrayMethod( &#x27;reduceRight&#x27; ),

        /**
         @method reverse

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse&quot;&gt;reverse&lt;/a&gt;
         */
        reverse: _mapArrayMethod( &#x27;reverse&#x27; ),

        /**
         @method shift

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift&quot;&gt;shift&lt;/a&gt;
         */
        shift: _mapArrayMethod( &#x27;shift&#x27; ),

        /**
         @method slice

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;slice&lt;/a&gt;
         */
        slice: _mapArrayMethod( &#x27;slice&#x27; ),

        /**
         @method some

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;some&lt;/a&gt;
         */
        some: _mapArrayMethod( &#x27;some&#x27; ),

        /**
         @method splice

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice&quot;&gt;splice&lt;/a&gt;
         */
        splice: _mapArrayMethod( &#x27;splice&#x27; ),

        /**
         @method unshift

         @return {object} - tb.dom() result set, may be empty

         inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift&quot;&gt;unshift&lt;/a&gt;
         */
        unshift: _mapArrayMethod( &#x27;unshift&#x27; ),

    };

    //console.log( &#x27;methods&#x27;, Object.keys(methods), methods );
    tb.extend( TbSelector.prototype, tb.methods );
    //console.log( &#x27;TbSelector.prototype&#x27;, Object.keys(TbSelector.prototype), TbSelector.prototype );

    /**
     @method unique
     @chainable

     @return {object} - tb.dom() result set, may be empty

     force this tb() result set to be unique

     ( being called after using methods inherited from array, force uniqueness )
     */
    TbSelector.prototype.unique = function() {
        var that = this,
            result = [];

        [].forEach.call(
            that,
            function ( pElement ) {
                if ( result.indexOf( pElement ) === -1 ){
                    result.push( pElement );
                }
            }
        );

        return tb.dom( result );
    };

    tb.plugin = (function( internalProto ) {
        return function (pMethodName, pFunction) {
            var p = internalProto;

            if (!p[pMethodName]) {
                p[pMethodName] = pFunction;
            } else {
                console.warn(&#x27;tb.plugin(): Cannot overload existing tb method (&#x27;, pMethodName, &#x27;)&#x27;);
            }

        };
    })( internaltb.prototype );

    return tb;

})();

// make it a node module
if (typeof module !== &#x27;undefined&#x27;) {
    module.exports = tb;
} else {
    /**
     * document.ready bootstrap
     */
    (function(){

        function domReady () {
            // find all tb head &amp; body nodes and add tb objects if not yet done
            tb.attach( document.head );
            tb.attach( document.body );
        }

        // Mozilla, Opera, Webkit
        if ( document.addEventListener ) {
            document.addEventListener( &quot;DOMContentLoaded&quot;, function(){
                document.removeEventListener( &quot;DOMContentLoaded&quot;, arguments.callee, false);
                domReady();
            }, false );

            // If IE event model is used
        } else if ( document.attachEvent ) {
            // ensure firing before onload
            document.attachEvent(&quot;onreadystatechange&quot;, function(){
                if ( document.readyState === &quot;complete&quot; ) {
                    document.detachEvent( &quot;onreadystatechange&quot;, arguments.callee );
                    domReady();
                }
            });
        }

    })();
}

/**
 @class tb.Event
 @constructor

 @param {string} pEventName - name of event
 @param [pEventData] - data to be appended to this event
 @param {string} [pBubble=l] - bubbling indicator, &#x27;l&#x27; = local, &#x27;u&#x27; = up, &#x27;d&#x27; = down or any combination

 @return {object} tb.Event instance
 */
tb.Event = function( pEventName, pEventData, pBubble ){
    var that = this;
    that.bubble = pBubble || &#x27;l&#x27;;
    that.data = pEventData || {};
    that.name = pEventName || &#x27;&#x27;;
    that.__stopped__ = that.__immediateStopped__ = false;
};

tb.Event.prototype = {

    /**
     @method stopPropagation
     
     @return {object} tb.Event object

     stop propagation after all handlers on this object have run
     */
    stopPropagation: function(){
        this.__stopped__ = true;
        return this;
    },

    /**
      @method stopImmediatePropagation
     
      @return {object} tb.Event object

      stop propagation immediately after this handler has run
     */
    stopImmediatePropagation: function(){
        this.__stopped__ = true; // also stop normal propagation
        this.__immediateStopped__ = true;
        return this;
    }

};

tb.debug = false; // todo: rethink / implement

tb.assumeTb = (function(pSetter){ 
    var isTb = pSetter;
    return function(pParam){
        if ( 
            typeof pParam === &#x27;object&#x27;
            &amp;&amp; !!pParam.nodeType
            &amp;&amp; pParam.nodeType === 1    // html node
            &amp;&amp; pParam !== document.head
            &amp;&amp; pParam.parentNode !== document.head
            &amp;&amp; tb.assumeTb()
        ){
            // scan for AACEs and load + re-insert
            //console.log(&#x27;scan for ACEs: &#x27;, pParam);
            var fileName, 
                lastIndex, 
                nameSpace,
                tagName;

            var selection = tb.dom(pParam)
                .children()
                .forEach(function(pElement){
                    var tagName = pElement.tagName.toLowerCase(),
                        isUndefinedACE = 
                            tagName.indexOf(&#x27;-&#x27;) !== -1
                            &amp;&amp; !window.customElements.get(tagName),
                        isLoading,
                        fileName,
                        hasTbClassCode;

                    fileName = tagName.split(&#x27;-&#x27;);
                    lastIndex = fileName.length - 1;

                    // normalize filename -&gt;
                    fileName[lastIndex] = 
                        fileName[lastIndex].substr(0,1).toUpperCase() +
                        fileName[lastIndex].substr(1).toLowerCase();
                            
                    nameSpace = fileName.join(&#x27;.&#x27;);

                    fileName = &#x27;/&#x27;+fileName.join(&#x27;/&#x27;) + &#x27;.js&#x27;;     

                    isLoading = !!tb.require.get(fileName),
                    hasTbClassCode = !!tb.namespace(nameSpace).get(); // jshint ignore:line

                    // create element definition callback
                    var define = (function( nameSpace, tagName, element ){ return function define(){

                        if( !window.customElements.get(tagName) ){

                            //console.log(&#x27;define&#x27;, tagName);
                            // auto-define autonomous custom element
                            customElements.define(
                                tagName, 
                                class extends HTMLElement{

                                    constructor(){
                                        super();
                                    }

                                    static get observedAttributes(){
                                        return Array
                                            .from( element.attributes )
                                            .map( function(pAttribute){ 
                                                return pAttribute.name; 
                                            });
                                    }

                                    connectedCallback(){
                                        var e = new tb(
                                            tb.namespace(nameSpace).get() || class extends Tb{}, // jshint ignore:line
                                            {},
                                            this
                                        );
                                        e.trigger(&#x27;connected&#x27;);
                                    }

                                    disconnectedCallback(){
                                        tb(this).trigger(&#x27;disconnected&#x27;);
                                    }

                                    adoptedCallback(){
                                        tb(this).trigger(&#x27;adopted&#x27;);
                                    }

                                    attributeChangedCallback( name, oldValue, newValue ){
                                        tb(this).trigger(&#x27;attributeChanged&#x27;, { name: name, oldValue: oldValue, newValue: newValue} );
                                    }

                                }
                            );

                        }

                    };})( nameSpace, tagName, pElement );

                    if (isUndefinedACE){
                        //console.log(&#x27;tagName&#x27;, tagName, &#x27;in&#x27;, pElement.parentNode );
                        if ( !hasTbClassCode ){
                            tb.require( fileName )
                                .then( define );
                        } else {
                            define();
                        }
                    }
 
                });
 
                // only recurse on those that are no ACEs
                tb.dom(pParam)
                    .children()
                    .filter(function(pElement){
                        var isNoACE = 
                            !!pElement.nodeType
                            &amp;&amp; pElement.nodeType === 1
                            &amp;&amp; pElement.tagName.indexOf(&#x27;-&#x27;) === -1;
 
                        return isNoACE;
                    })
                    .forEach(function(pElement){
                        tb.assumeTb(pElement);
                    });
 
            return selection;
        } else if ( typeof pParam === &#x27;boolean&#x27;){
            isTb = pParam;
        }
        return isTb;
    };
})(false); // dont assume custom tags to resolve to tB classes


if (typeof module === &#x27;undefined&#x27; ){
    tb.dom = (function () {

        // Variables
        var regExReturn = /\r/g,
            regExSpaces = /[\x20\t\r\n\f]+/g,
            regExWord = /\S+/g,
            regExHtml = /^&lt;&gt;$/g,
            TbSelector = tb.Selector,
            dom,
            f;

        // INTERNAL ONLY Private Functions
        function _addEvent( pDomNode, pEventName, pHandler, pCapture ) {
            if (pDomNode.attachEvent) {
                pDomNode.attachEvent(&#x27;on&#x27; + pEventName, pHandler, pCapture );
            } else {
                pDomNode.addEventListener(pEventName, pHandler, pCapture );
            }
        }

        function _removeEvent( pDomNode, pEventName, pHandler, pCapture ) {
            if (pDomNode.detachEvent){
                pDomNode.detachEvent(&#x27;on&#x27;+pEventName, pHandler, pCapture );
            } else {
                pDomNode.removeEventListener(pEventName, pHandler, pCapture );
            }
        }

        function _htmlToElements(html) {
            var template = document.createElement(&#x27;template&#x27;);
            template.innerHTML = html;
            template.normalize();
            return !template[&#x27;content&#x27;][&#x27;childNodes&#x27;] 
                ? Array.from(template.childNodes) 
                : Array.from(template.content.childNodes);
        }

        function _mapArrayMethod( pMethodName ){
            var method = [][pMethodName];

            if ( -1 &lt; ([ &#x27;push&#x27;, &#x27;unshift&#x27; ]).indexOf( pMethodName ) ){ // make these array methods chainable
                return function(){
                    method.apply( this, arguments );

                    return this.unique();
                };
            } else {
                return function(){
                    var ret = method.apply( this, arguments );

                    return ret instanceof Array &amp;&amp; !!ret[&#x27;0&#x27;] &amp;&amp; !!ret[&#x27;0&#x27;][&#x27;nodeType&#x27;] ? tb.dom( ret ).unique() : ret;
                };
            }
        }

        /**
         @class tb.dom
         @constructor

         @param [pSelector] a .querySelectorAll() selector string, a dom node or an array of dom nodes
         @param [pDomNode] - DOM node to start search in

         @return {object} - tb.dom() result set, may be empty

         tb.dom() function

         jquery like selector engine

         */

        dom = function tbDom(pSelector, pDomNode) {

            var that = this,
                domNode,
                nodeList;

            if (!pSelector) { // no selector given, or a falsy value
                return that;
            } 

            // ... implicit else do:
            if (!!pSelector[&#x27;nodeType&#x27;] ) { // selector is a dom node
                if ( [].indexOf.call( that, pSelector ) === -1 ){
                    [].push.call(that, pSelector);
                }
                return;
            } else if ( !!pSelector[&#x27;__tbSelector__&#x27;] ) { // selector is a tb.dom result set
                return pSelector;
            } else if ( pSelector instanceof TbSelector &amp;&amp; !!pSelector[0] ) { // a twobirds selector result set
                [].forEach.call(
                    pSelector,
                    function (pElement) {   // copy only DOM nodes
                        if (
                            !!pElement[&#x27;target&#x27;]
                            &amp;&amp; !!pElement[&#x27;target&#x27;][&#x27;nodeType&#x27;]
                        ) {
                            if ( [].indexOf.call( that, pElement.target ) === -1 ){
                                [].push.call(that, pElement.target);
                            }
                        }
                    }
                );
                return;
            } else if ( pSelector instanceof Array
                || !!pSelector[&#x27;__tbSelector__&#x27;]
                || pSelector instanceof HTMLCollection
                || pSelector instanceof NodeList ) {
                [].forEach.call(
                    pSelector,
                    function ( pElement ) {
                        tb.dom( pElement )
                            .forEach(
                                function( pFoundDomNode ){
                                    if ( [].indexOf.call( that, pFoundDomNode ) === -1 ){
                                        [].push.call(
                                            that,
                                            pFoundDomNode
                                        );
                                    }
                                }
                            );
                    }
                );
                return;
            } else if (typeof pSelector !== &#x27;string&#x27;) { // wrong selector type
                return;
            } else { // pSelector is a string

                // uses &#x27;template&#x27; element to retrieve DOM nodes
                var DOM = _htmlToElements( 
                    pSelector   // compress template string
                        .split(&#x27;\n&#x27;)
                        .map( (e) =&gt; e.trim().replace( /\t/g, &#x27;&#x27;) )
                        .map( (e) =&gt; e.substr(-1) === &#x27;&gt;&#x27; ? e : e + &#x27; &#x27; )
                        .join(&#x27;&#x27;)
                        .trim()
                ); 

                if ( DOM.length === 1 
                    &amp;&amp; !!DOM[0].nodeType
                    &amp;&amp; DOM[0].nodeType === 3 // nodeType 3 indicates text node
                ){ // it is not a HTML string, but a simple string --&gt; it is regarded a CSS selector
                    domNode = !!pDomNode &amp;&amp; !!pDomNode[&#x27;nodeType&#x27;] ? pDomNode : document;
                    pSelector
                        .split( &#x27;,&#x27; )
                        .forEach(
                            function forEachTbDomSelector( pThisSelector ){
                                nodeList = domNode.querySelectorAll(pThisSelector.trim());
                                if (!!nodeList[0]) {
                                    [].forEach.call(
                                        nodeList,
                                        function (pDomElement) {
                                            if ( [].indexOf.call( that, pDomElement ) === -1 ){
                                                [].push.call( that, pDomElement );
                                            }
                                        }
                                    );
                                }

                            }
                        );

                } else { // it is a HTML string
                    // return html content as a set of nodes
                    var dom = tb.dom( DOM );
                    //dom.clean();
                    return dom;
                }
            }

        };

        // dom prototype, public functions
        dom.arrayMethods = {

            __tbSelector__: true,   // detection

            length: 0,

            // from Array prototype
            /**
             @method concat
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/concat&quot;&gt;concat&lt;/a&gt;
             */
            concat: _mapArrayMethod( &#x27;concat&#x27; ),

            /**
             @method every
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;every&lt;/a&gt;
             */
            every: _mapArrayMethod( &#x27;every&#x27; ),

            /**
             @method forEach
             @chainable

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;forEach&lt;/a&gt;
             */
            forEach: _mapArrayMethod( &#x27;forEach&#x27; ),

            /**
             @method indexOf

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;indexOf&lt;/a&gt;
             */
            indexOf: _mapArrayMethod( &#x27;indexOf&#x27; ),

            /**
             @method map

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;map&lt;/a&gt;
             */
            map: _mapArrayMethod( &#x27;map&#x27; ),

            /**
             @method pop

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/pop&quot;&gt;pop&lt;/a&gt;
             */
            pop: _mapArrayMethod( &#x27;pop&#x27; ),

            /**
             @method push

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push&quot;&gt;push&lt;/a&gt;
             */
            push: _mapArrayMethod( &#x27;push&#x27; ),

            /**
             @method reduce

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;reduce&lt;/a&gt;
             */
            reduce: _mapArrayMethod( &#x27;reduce&#x27; ),

            /**
             @method reduceRight

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight&quot;&gt;reduceRight&lt;/a&gt;
             */
            reduceRight: _mapArrayMethod( &#x27;reduceRight&#x27; ),

            /**
             @method reverse

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse&quot;&gt;reverse&lt;/a&gt;
             */
            reverse: _mapArrayMethod( &#x27;reverse&#x27; ),

            /**
             @method shift

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/shift&quot;&gt;shift&lt;/a&gt;
             */
            shift: _mapArrayMethod( &#x27;shift&#x27; ),

            /**
             @method slice

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/slice&quot;&gt;slice&lt;/a&gt;
             */
            slice: _mapArrayMethod( &#x27;slice&#x27; ),

            /**
             @method some

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;some&lt;/a&gt;
             */
            some: _mapArrayMethod( &#x27;some&#x27; ),

            /**
             @method splice

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/splice&quot;&gt;splice&lt;/a&gt;
             */
            splice: _mapArrayMethod( &#x27;splice&#x27; ),

            /**
             @method unshift

             @return {object} - tb.dom() result set, may be empty

             inherited from Array, see &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift&quot;&gt;unshift&lt;/a&gt;
             */
            unshift: _mapArrayMethod( &#x27;unshift&#x27; ),
        };

        // functions
        dom.methods = (function(){

            /**
             @method add
             @chainable

             @param  pSelector - any valid tb.dom() constructor parameter

             @return {object} - tb.dom() result set, may be empty

             add all nodes in tb.dom( pSelector ) result set to tb.dom() result set
             */
            function add( pSelector ) {
                var that = this,
                    res;

                if ( typeof pSelector !== &#x27;string&#x27; &amp;&amp; !!pSelector[&#x27;length&#x27;] ) { // if array given add each of its elements
                    [].forEach.call(
                        pSelector,
                        function ( pSelected ) {
                            res = tb.dom( pSelected ).toArray();
                            res.forEach(
                                function( pDomNode ){
                                    if ( [].indexOf.call( that, pDomNode ) === -1 ){
                                        [].push.call(
                                            that,
                                            pDomNode
                                        );
                                    }
                                }
                            );
                        }
                    );
                } else { // pSelector not an array
                    res = tb.dom( pSelector ).toArray();
                    res.forEach(
                        function( pDomNode ){
                            if ( [].indexOf.call( that, pDomNode ) === -1 ){
                                [].push.call(
                                    that,
                                    pDomNode
                                );
                            }
                        }
                    );
                }

                return that.unique();
            }

            /**
             @method addClass
             @chainable

             @param  {string} pClassName - class name(s) to add, separated by &#x27; &#x27;

             @return {object} - tb.dom() result set, may be empty

             add class name to each of tb.dom() result set
             */
            function addClass(pClassNames) {

                var that = this;

                if ( !pClassNames || typeof pClassNames !== &#x27;string&#x27; ){
                    console.warn( &#x27;method addClass: missing or wrong pClassNames&#x27; );
                    return that;
                }

                var givenClassNames = pClassNames
                    .split(&#x27; &#x27;)
                    .filter(function(pElement){ 
                        return !!pElement; 
                    });

                that.forEach(
                    function( pDomNode ){
                        var existingClasses = ( pDomNode.getAttribute(&#x27;class&#x27;) || &#x27;&#x27; )
                                .split(&#x27; &#x27;)
                                .filter(function(pElement){ 
                                    return !!pElement; 
                                });

                        givenClassNames.forEach(function(pGivenClassName){

                            if ( existingClasses.indexOf( pGivenClassName ) === -1) {
                                existingClasses.push( pGivenClassName );
                            }

                        });

                        pDomNode.setAttribute(&#x27;class&#x27;, existingClasses.join(&#x27; &#x27;) );

                    }

                );

                return that;
            }

            /**
             @method append
             @chainable

             @param pElement - an array like set of DOM nodes, or a single DOM node

             @return {object} - tb.dom() result set, may be empty

             appends given DOM nodes to every node in tb.dom() result set
             */
            function append( pElement ){
                var that = this,
                    nodes;

                that.forEach(
                    function( pDomNode ){
                        nodes = tb.dom( pElement );
                        [].forEach.call(
                            nodes,
                            function( pThisElement ){
                                if ( !!pThisElement[&#x27;nodeType&#x27;] ){
                                    pDomNode.appendChild( pThisElement );
                                }
                            }
                        );
                        setTimeout(function(){
                            tb.assumeTb( pDomNode );
                        },0);
                    }
                );

                return that;
            }

            /**
             @method appendTo

             @param pElement - a dom node or tb.dom() result set

             appends all elements in this result set to DOM node or tb.dom(...)[0] first element of result set
             */
            function appendTo( pElement ){
                var that = this;

                pElement = tb.dom( pElement ); // all types of selectors, only first result

                if ( !!pElement[&#x27;0&#x27;] ){
                    pElement = pElement[0];
                    that.forEach(
                        function( pDomNode ){
                            pElement.appendChild( pDomNode );
                        }
                    );
                }

                setTimeout(function(){
                    tb.assumeTb( pElement );
                },0);

                return that;
            }

            /**
             @method attr
             @chainable

             @param pKey - if string: DOM node attribute name; if object: hash of attributeName: attributeValue
             @param {string} [pValue] - value to set in DOM node(s)

             @return {object} - tb.dom() result set, may be empty

             set of get attribute values to each DOM node in give tb.dom() result set

             HINT:
             if pKey is a string and pValue is not given its a GET
             if pKey is an object or pKey(string) and pValue(string) are given, it is a SET. ONLY THEN this is CHAINABLE.
             */
            function attr(pKey, pValue) {

                var that = this,
                    rootNodes,
                    attributes = {};

                if ( typeof pKey === &#x27;object&#x27; ){ // it is a hash object
                    
                    Object
                        .keys( pKey )
                        .forEach(function( pPropName ){
                            that.forEach( function( pDomNode ){
                                tb.dom( pDomNode ).attr( pPropName, pKey[pPropName] );
                            });
                        });

                    return that;
                }

                // if no arguments, return attribute object of first in list
                if (!arguments.length) {
                    [].forEach.call(
                        that[0].attributes,
                        function( pAttribute ){
                            attributes[ pAttribute.name ] = pAttribute.value;
                        }
                    );
                    return attributes;
                }

                // if no value is given and there are elements, return attribute value of first in list
                if ( pValue === undefined &amp;&amp; that.length &gt; 0 ) {
                    return that[0].getAttribute(pKey);
                }

                // if a value to set is given, apply to all nodes in list
                rootNodes = that.toArray();
                rootNodes.forEach(
                    function (pNode) {
                        pNode.setAttribute(pKey, pValue);
                    }
                );

                return that;
            }

            /**
             @method children
             @chainable

             @param  pSelector - any valid tb.dom() constructor parameter

             @return {object} - tb.dom() result set, may be empty

             return child nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
             */
            function children(pSelector) {

                var that = this,
                    result = tb.dom();

                that.forEach(
                    function (pDomNode) {
                        var check = pSelector !== undefined ? tb.dom( pSelector ) : false;

                        [].forEach.call(
                            pDomNode.children,
                            function( pChildNode ){
                                if ( -1 === [].indexOf.call( result, pChildNode )
                                    &amp;&amp; ( !check || -1 &lt; [].indexOf.call( check, pChildNode ) )
                                ){
                                    result.push( pChildNode );
                                }
                            }
                        );
                    }
                );

                return result;
            }

            /**
             @method clean
             @chainable

             @return {object} - tb.dom() result set, may be empty

             - normalizes text nodes
             - removes comment nodes
             */
            var clean = (function(doClean){ return function clean(pParam){

                var that = this,
                    node;

                if (pParam !== undefined){
                    doClean = !pParam ? false : true;
                } else if (doClean){
                    that.forEach(
                        function( pElement ){
                            var treeWalker = document.createTreeWalker(
                                    pElement,
                                    128 + 4    // comment nodes + text nodes
                                );

                            while(treeWalker.nextNode()){
                                node = treeWalker.currentNode; 
                                if (
                                    node.nodeType === 8
                                    || (
                                        node.nodeType === 3
                                        &amp;&amp; node.textContent.replace( /[\s]/g,&#x27;&#x27;).length === 0
                                    )
                                ){
                                    // we need to IIFE so the node pointer is copied, 
                                    // otherwise it will only remove the last comment node of that while loop
                                    setTimeout((function(pNode){ return function(){ // jshint ignore:line
                                        pNode.remove();
                                    }; })( node ), 0);
                                }
                            }

                            setTimeout( function(){ 
                                pElement.normalize();
                            }, 0);

                        }
                    );
                }
                return that;
            };})(true);

            /**
             @method descendants
             @chainable

             @param  pSelector - any valid tb.dom() constructor parameter

             @return {object} - tb.dom() result set, may be empty

             return all descendant nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
             */
            function descendants( pSelector ) {

                var that = this,
                    result = [],
                    ret,
                    check = !!pSelector ? tb.dom( pSelector ) : false;

                that
                    .forEach(
                        function( pDomNode ){
                            result = result.concat( tb.dom( pDomNode.querySelectorAll( &#x27;*&#x27; ) ).toArray() );
                        }
                    );

                result = tb.dom( result ).unique().toArray();

                if ( check ){
                    ret = result
                        .filter(
                            function( pDomNode ){
                                return -1 &lt; [].indexOf.call( check, pDomNode );
                            }
                        );
                }

                return tb.dom( check ? ret : result );
            }

            /**
             @method empty
             @chainable

             @return {object} - tb.dom() result set, may be empty

             removes one or all DOM event handlers from each element in tb.dom() result set
             */
            function empty() {
                var that = this;

                that.forEach(
                    function( pNode ){
                        pNode.innerHTML = &#x27;&#x27;;
                    }
                );

                return that;
            }

            /**
             @method filter
             @chainable

             @param pSelector - tb.dom() selector to match against or [].filter.call( this, function(){ ... } )

             @return {object} - tb.dom() result set

             match tb.dom() result set against pSelector filter
             */
            function filter( pSelector ) {

                var that = this,
                    compare = tb.dom( pSelector ),// functions and undefined will be ignored, so empty result then
                    result;

                if ( pSelector === &#x27;undefined&#x27; ) {
                    return that;
                }    // unchanged

                if ( typeof pSelector === &#x27;string&#x27; ) { // DOM selector given
                    result = [].filter.call(
                        that,
                        function (pElement) {
                            return -1 &lt; compare.indexOf(pElement);
                        }
                    );
                } else if ( pSelector instanceof Function ) { // function given
                    result = [].filter.call(
                        that,
                        pSelector
                    );
                }

                return tb.dom(result);
            }

            /**
             @method first
             @chainable

             @return {object} - tb.dom() result set, may be empty

             return tb.dom() result set, that contains only the first element in tb.dom( pSelector ) result set
             */
            function first() {

                var that = this,
                    result = tb.dom();

                if ( !!tb.dom.length ){
                    result.push( that[0] );
                }

                return result;
            }

            /**
             @method hasClass
             @param pClass {string} - class name

             @return {boolean} - true if class in className
             */
            function hasClass( pClass ) {
                var that = this,
                    node = !!that[0] ? that[0] : false;

                if ( node ){
                    return node.className.split( &#x27; &#x27; ).indexOf( pClass ) &gt; -1;
                }
                return;
            }

            /**
             @method hide
             @chainable

             @return {object} - tb.dom() result set, may be empty

             hide all nodes in tb.dom() result set
             */
            function hide() {
                var that = this;

                that.forEach(
                    function( pNode ){
                        var prev = window.getComputedStyle(pNode).getPropertyValue(&#x27;display&#x27;);
                        pNode.style.prevDisplay = !! prev &amp;&amp; prev !== &#x27;none&#x27;
                            ? prev
                            : &#x27;inline&#x27;;
                        pNode.style.display = &#x27;none&#x27;;
                    }
                );

                return that;
            }

            /**
             @method html
             @chainable

             @param {string} pHtml - html string or empty string

             @return {object} - tb.dom() result set, may be empty

             replace all nodes .innerHTML with pHtml
             */
            function html( pHtml ) {
                var that = this;

                if ( typeof pHtml !== &#x27;undefined&#x27; ){
                    if ( typeof pHtml === &#x27;string&#x27; ) {
                        that.forEach(
                            function (pNode) {
                                pNode.innerHTML = pHtml;
                            }
                        );
                    }
                } else {
                    return !!that[0] ? that[0].innerHTML : &#x27;&#x27;;
                }

                return that;
            }

            /**
             @method insertAfter

             @param pElement - a single DOM node or tb.dom() selector result set, [0] is taken

             inserts all elements in tb.dom() result set after given DOM node
             */
            function insertAfter( pTarget ){
                var that = this,
                    target = tb.dom( pTarget )[&#x27;0&#x27;] ? tb.dom( pTarget )[&#x27;0&#x27;] : false,
                    nextDomNode = target.nextSibling || false;

                if ( !target ) {
                    return;
                }

                that.forEach(
                    function( pDomNode ){
                        if ( !!pDomNode.nodeType ){

                            if ( nextDomNode ){
                                target
                                    .parentElement
                                    .insertBefore(
                                        pDomNode.cloneNode( true ),
                                        nextDomNode
                                    );
                            } else {
                                target
                                    .parentElement
                                    .appendChild(
                                        pDomNode.cloneNode( true )
                                    );
                            }

                        }
                    }
                );

                setTimeout(function(){
                    tb.assumeTb( pTarget );
                },0);

                return that;
            }

            /**
             @method insertBefore

             @param pElement - a single DOM node or tb.dom() selector result set, [0] is taken

             prepends all elements in tb.dom() result set to given DOM node
             */
            function insertBefore( pTarget ){
                var that = this,
                    target = tb.dom( pTarget )[&#x27;0&#x27;] ? tb.dom( pTarget )[&#x27;0&#x27;] : false;

                if ( !target ) {
                    return;
                }

                that.forEach(
                    function( pDomNode ){
                        if ( !!pDomNode.nodeType ){

                            target.parentElement
                                .insertBefore(
                                    pDomNode.cloneNode( true ),
                                    pTarget
                                );

                        }
                    }
                );

                tb.dom( pTarget ).clean();
                tb.assumeTb( pTarget );

                return that;
            }

            /**
             @method last
             @chainable

             @return {object} - tb.dom() result set, may be empty

             return tb.dom() result set, that contains only the last element in tb.dom( pSelector ) result set
             */
            function last() {

                var that = this,
                    result = tb.dom();

                if ( !!tb.dom.length ){
                    result.push( that.pop() );
                }

                return result;
            }

            /**
             @method next
             @chainable

             @return {object} - tb.dom() result set, may be empty

             return tb.dom() result set, that contains only the next element 
             of the first element in tb.dom( pSelector ) result set
             */
            function next() {

                var that = this,
                    result = tb.dom();

                if ( !!tb.dom.length ){
                    if ( !!that[0].nextSibling ){
                        result.push( that[0].nextSibling );
                    }
                }

                return result;
            }

            /**
             @method not
             @chainable

             @param  pSelector - any valid tb.dom() constructor parameter

             @return {object} - tb.dom() result set, may be empty

             remove all nodes from this tb.dom() result set, that are in tb.dom( pSelector ) result set
             */
            function not(pSelector) {
                var that = this,
                    check = pSelector !== undefined ? document.querySelectorAll( pSelector ) : false;

                if ( !check ){
                    return that;
                }

                check.forEach(function (pElement) {
                    var i = [].indexOf.call( that, pElement);
                    if (  i &gt; -1 ) {
                        [].splice.apply( that, [ i, 1 ] );
                    }
                });

                return that;
            }

            /**
             @method off
             @chainable

             @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
             @param {function} pHandler - callback far event
             @param {boolean} [pCapture] - callback far event

             @return {object} - tb.dom() result set, may be empty

             removes one or all DOM event handlers from each element in tb.dom() result set
             */
            function off( pEventName, pHandler, pCapture ){
                var that = this,
                    eventNames = pEventName.indexOf(&#x27; &#x27;) &gt; -1 ? pEventName.split(&#x27; &#x27;) : [ pEventName ],
                    capture = typeof pCapture === &#x27;boolean&#x27; ? pCapture : false;

                that.forEach(
                    function( pDomNode ){
                        if ( !!pDomNode.nodeType ){
                            if ( !!pHandler ){
                                eventNames.forEach(
                                    function( pThisEventName ){
                                        _removeEvent( pDomNode, pThisEventName, pHandler, capture );
                                    }
                                );
                            } else {
                                eventNames.forEach(
                                    function( pThisEventName ){
                                        // todo: refactor this, doesnt seem to work
                                        pDomNode[&#x27;on&#x27; + pThisEventName] = null;
                                        pDomNode.removeAttribute( &#x27;on&#x27; + pThisEventName );
                                    }
                                );
                            }
                        }
                    }
                );

                return that;
            }

            /**
             @method on
             @chainable

             @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
             @param {function} pHandler - callback for event
             @param {boolean} pCapture - indicates running in capture phase, that is top down

             @return {object} - tb.dom() result set, may be empty

             creates a DOM event handler for each element in tb.dom() result set
             */
            function on( pEventName, pHandler, pCapture ){
                var that = this,
                    eventNames = pEventName.indexOf(&#x27; &#x27;) &gt; -1 ? pEventName.split(&#x27; &#x27;) : [ pEventName ],
                    onceHandler,
                    capture = typeof pCapture === &#x27;boolean&#x27; ? pCapture : false;

                // if to be called only once
                if ( !!pHandler.once ){

                    onceHandler = (function(pHandler, pCapture) {
                        return function myOnceHandler(ev){
                            
                            // remove handlers
                            that.forEach(
                                function( pDomNode ){
                                    if ( !!pDomNode.nodeType ){
                                        eventNames.forEach(
                                            function( pThisEventName ){
                                                _removeEvent( pDomNode, pThisEventName, onceHandler, capture );
                                            }
                                        );
                                    }
                                }
                            );

                            pHandler.apply( ev, arguments );
                        };
                    })(pHandler, pCapture);

                    // needed to remove handlers from ALL dom elements
                    onceHandler.that = that;

                    // needed for .off()
                    onceHandler.remove = function removeOnceHandlers(){

                        // remove handlers
                        that.forEach(
                            function( pDomNode ){
                                if ( !!pDomNode.nodeType ){
                                    eventNames.forEach(
                                        function( pThisEventName ){
                                            _removeEvent( pDomNode, pThisEventName, onceHandler, capture );
                                        }
                                    );
                                }
                            }
                        );

                    };

                }

                // attach handler
                that.forEach(
                    function( pDomNode ){
                        if ( !!pDomNode.nodeType ){
                            eventNames.forEach(
                                function( pThisEventName ){
                                    _addEvent( pDomNode, pThisEventName, onceHandler || pHandler, capture );
                                }
                            );
                        }
                    }
                );

                return !!onceHandler ? onceHandler : that;
            }

            /**
            @method one
            
            @param {string} pEventName(s) - name(s) of the event separated by &#x27; &#x27;
            @param {function} pHandler - callback far event
            @param {boolean} pCapture - indicates running in capture phase, that is top down

            @return {function} - the onceHandler function

            creates a DOM event handler for each element in tb.dom() result set (to be called only once)

            - after the first call ALL event handlers that were attached to the dom elements are deleted automatically.
            - to remove all these onceHandlers manually, use the returned onceHandler and its .that property.
            - use 

            @example

                // create a handler
                var f=function(){ 
                    console.log(&#x27;a&#x27;); 
                }

                // attach handler to multiple divs
                var oh = tb.dom( &#x27;div&#x27; ) // each of the divs will respond with handlers, but afterwards all attached handlers are deleted
                    .one(
                        &#x27;click&#x27;,
                        f
                    );

                // use this if you want to remove certain onceHandlers manually ( not ALL of them which is next )
                console.log( oh );   // the onceHandler function created
                console.log( oh.that );   // the original tb.dom selection, used to delete some oh handlers manually if needed
                console.log( oh.remove );  // the function that deletes ALL once handlers

                // remove all handlers created by .one()
                tb.dom( &#x27;.myBotton&#x27; )   // a click on a certain button will remove ALL onceHandlers
                    .one(
                        &#x27;click&#x27;,
                        f.remove
                    );

            */
            function one( pEventName, pHandler, pCapture ){
                var that = this;

                pHandler.once = true;

                return that.on( pEventName, pHandler, pCapture );
            }

            /**
            @method parents
            @chainable

            @param  pSelector - any valid tb.dom() constructor parameter

            @return {object} - tb.dom() result set, may be empty

            return all parent nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
            */
            function parents(pSelector) {

                var that = this,
                    result = tb.dom(),
                    check = pSelector !== undefined ? tb.dom( pSelector ) : false,
                    domNode;

                that.forEach(
                    function (pDomNode) {
                        domNode = pDomNode.parentNode;

                        while (!!domNode
                        &amp;&amp; !!domNode[&#x27;tagName&#x27;]
                        &amp;&amp; domNode[&#x27;tagName&#x27;] !== &#x27;HTML&#x27;
                            ){
                            if ([].indexOf.call(result, domNode) === -1
                                &amp;&amp; ( !check || -1 &lt; [].indexOf.call( check, domNode ) )
                            ) {
                                result.push(domNode);
                            }
                            domNode = domNode.parentNode;
                        }
                    }
                );

                return result;
            }

            /**
             @method parent
             @chainable

             @param  pSelector - any valid tb.dom() constructor parameter

             @return {object} - tb.dom() result set, may be empty

             return closest parent nodes of tb.dom() result set, that match nodes in tb.dom( pSelector ) result set
             */
            function parent(pSelector){
                var that = this,
                    result = tb.dom(),
                    check = pSelector !== undefined ? tb.dom( pSelector ) : false;

                that.forEach(
                    function (pDomNode) {
                        var domNode = pDomNode.parentNode;

                        if ( -1 === [].indexOf.call( result, domNode )
                            &amp;&amp; ( !check ||  -1 &lt; [].indexOf.call( check, domNode ) )
                        ){
                            [].push.call( result, domNode);
                        }
                    }
                );

                return result;
            }

            /**
             @method previous
             @chainable

             @return {object} - tb.dom() result set, may be empty

             return tb.dom() result set, that contains only the previous element 
             of the first element in tb.dom( pSelector ) result set
             */
            function previous() {

                var that = this,
                    result = tb.dom();

                if ( !!tb.dom.length ){
                    if ( !!that[0].previousSibling ){
                        result.push( that[0].previousSibling );
                    }
                }

                return result;
            }

            /**
             @method remove
             @chainable

             @param [pDomElements] - a tb.dom() selector result set
             @return {object} - tb.dom() result set containing removed DOM nodes

             removes all elements in tb.dom() result set from DOM
             */
            function remove( pDomNodes ){
                var that = this;

                that.forEach(
                    function( pDomNode, pIndex ){
                        that[ pIndex ] = pDomNode.parentNode.removeChild( pDomNode );
                    }
                );

                return that;
            }

            /**
             @method removeAttr
             @chainable

             @param {string} pKeys - attribute name(s) separated by &#x27; &#x27;

             @return {object} - tb.dom() result set, may be empty

             remove attribute(s) completely from tb.dom() result set
             */
            function removeAttr(pKeys) {

                var that = this,
                    attrNames = pKeys &amp;&amp; pKeys.match(regExWord),
                    name,
                    i;

                that.forEach(
                    function (pDomNode) {
                        i = 0;
                        if (attrNames &amp;&amp; !!pDomNode[&#x27;nodeType&#x27;] &amp;&amp; pDomNode.nodeType === 1) {
                            while ((name = attrNames[i++])) {
                                pDomNode.removeAttribute(name);
                            }
                        }
                    }
                );

                return that;
            }

            /**
             @method removeClass
             @chainable

             @param  {string} pClassName - class name(s) to remove, separated by &#x27; &#x27;

             @return {object} - tb.dom() result set, may be empty

             remove class name from each of tb.dom() result set
             */
            function removeClass(pRemoveClasses) {

                var that = this,
                    removeClasses = pRemoveClasses
                        .split(&#x27; &#x27;)
                        .filter(function(pElement){ 
                            return !!pElement; 
                        });

                that.forEach(
                    function ( pDomNode ) {

                        var existingClasses = ( pDomNode.getAttribute(&#x27;class&#x27;) || &#x27;&#x27; )
                                .split(&#x27; &#x27;)
                                .filter(function(pElement){ 
                                    return !!pElement; 
                                });

                        removeClasses.forEach(
                            function( pRemoveClass ){

                                while ( existingClasses.indexOf(pRemoveClass) &gt; -1 ){
                                    existingClasses.splice(existingClasses.indexOf(pRemoveClass), 1);
                                }

                                if ( !!existingClasses.length ){
                                    tb.dom( pDomNode ).attr(&#x27;class&#x27;, existingClasses.join(&#x27; &#x27;) );
                                } else {
                                    tb.dom( pDomNode ).removeAttr(&#x27;class&#x27;);
                                }
                                
                            }
                        );

                    }
                );

                return that;
            }

            /**
             @method show
             @chainable

             @return {object} - tb.dom() result set, may be empty

             show all nodes in tb.dom() result set
             */
            function show() {
                var that = this;

                that.forEach(
                    function( pDomNode ){
                        pDomNode.style.display = !!pDomNode.style.prevDisplay
                            ? pDomNode.style.prevDisplay
                            : &#x27;block&#x27;;
                    }
                );

                return that;
            }

            /**
             @method toArray
             @chainable

             @return {object} - tb.dom() result set converted to a plain array of DOM nodes

             convert tb.dom() result set converted to a plain array of DOM nodes
             */
            function toArray(){
                var that = this;

                return Array.from(that);
            }

            /**
             @method toggleClass
             @param pClassName {string} - class name
             @chainable

             @return {object} - tb.dom() result set

             if className is set in class attribute, it is deleted, otherwise it is set.
             */
            function toggleClass( pClassName ) {
                var that = this,
                    $pNode;

                that.forEach(
                    function( pNode ){

                        $pNode = tb.dom( pNode );

                        $pNode[ $pNode.hasClass(pClassName) ? &#x27;removeClass&#x27; : &#x27;addClass&#x27; ]( pClassName );

                    }
                );

                return that;
            }

            /**
             @method trigger
             @chainable

             @param {string} pEventName - name of the event
             @param {object} [pData] - optional data
             @param {boolean} [pBubble] - bubble event, default = true
             @param {boolean} [pCancel] - cancelable event, default = true, if false e.preventDefault() in handler will have no effect

             @return {object} - tb.dom() result set, may be empty

             creates a DOM event for each element in tb.dom() result set
             */
            function trigger( pEventName, pData, pBubble, pCancel ){
                var bubble = typeof pBubble === &#x27;boolean&#x27; ? pBubble : true,
                    cancel = typeof pCancel === &#x27;boolean&#x27; ? pCancel : true,
                    that = this,
                    eventNames = pEventName.split(&#x27; &#x27;),
                    e;

                that.forEach(
                    function( pDomNode ){
                        if ( !!pDomNode.nodeType ){
                            eventNames.forEach(
                                function( pThisEventName ){
                                    if (&#x27;createEvent&#x27; in document) {
                                        e = document.createEvent(&#x27;HTMLEvents&#x27;);
                                        tb.extend(
                                            e.data,
                                            pData
                                        );
                                        e.initEvent(pThisEventName, bubble, cancel );
                                        pDomNode.dispatchEvent(e);
                                    } else {
                                        e = document.createEventObject();
                                        tb.extend(
                                            e.data,
                                            pData
                                        );
                                        e.eventType = pThisEventName;
                                        pDomNode.fireEvent(&#x27;on&#x27;+e.pThisEventName, e);
                                    }
                                }
                            );
                        }
                    }
                );

                return that;
            }

            /**
             @method unique
             @chainable

             @return {object} - tb.dom() result set, may be empty

             force this tb.dom() result set to be unique ( HINT: if this is necessary, there is an error in twoBirds,
             and we would like to hear about it... )

             method is called internally though to force result set uniqueness
             */
            function unique() {
                var that = this,
                    result = [];

                [].forEach.call(
                    that,
                    function ( pElement ) {
                        if ( result.indexOf( pElement ) === -1 ){
                            result.push( pElement );
                        }
                    }
                );

                return tb.dom( result );
            }

            /**
             @method val
             @chainable

             @param {string} [pValue] - value to set to DOM input type element

             @return [pValue] - value from input element [0] in tb.dom() result set

             if pValue given, it is a SET and the method is chainable
             if no pValue given, it is a GET and the method will return the value
             */
            function val( pValue ){

                var that = this,
                    inputTags = (&#x27;input select textarea&#x27;).split( &#x27; &#x27; ),
                    excludeTypes = (&#x27;button file image reset submit&#x27;).split( &#x27; &#x27; ),
                    ret;

                function isInput( pElement ){
                    return pElement.nodeType === 1
                        &amp;&amp; ( inputTags ).indexOf( pElement.tagName.toLowerCase() ) &gt; -1
                        &amp;&amp; ( excludeTypes ).indexOf( pElement.type ) === -1;
                }

                var valHandlers = {

                    &#x27;select&#x27;: function selectVal( pValue ){

                        var that = this,
                            multiSelect = that.type === &quot;select-multiple&quot;,
                            ret;

                        if ( !arguments.length ) { // getter

                            ret = [];

                            [].forEach.call(
                                that.selectedOptions,
                                function( pOption ){
                                    if ( pOption.selected ){
                                        if ( !pOption.disabled
                                            &amp;&amp; ( !pOption.parentNode.disabled
                                            || pOption.parentNode.nodeName !== &quot;optgroup&quot; )
                                        ){
                                            var value = pOption.value;

                                            ret.push( value );
                                        }                                    }
                                }
                            );

                            // if multiselect return array if single return value or empty string for not selected
                            return multiSelect ? ret : !!ret[0] ? ret[0] : &#x27;&#x27;;

                        } else { // setter

                            // if single value given convert to array
                            pValue = pValue.constructor !== Array ? [ pValue ] : pValue;

                            // if not multiSelect but array given set array to first value
                            pValue = !multiSelect &amp;&amp; pValue.constructor === Array ? [ pValue[0] ] : pValue;

                            // set options
                            [].forEach.call(
                                that.options,
                                function( pOption ){
                                    var valIndex = pValue.indexOf( pOption.value ),
                                        val;

                                    if ( valIndex + 1 ){
                                        val = pValue[ valIndex ];
                                        pOption.selected = !!val;
                                    } else {
                                        pOption.selected = false;
                                    }

                                }
                            );

                            // set given &#x27;selected&#x27; attributes
                            pValue
                                .forEach(
                                    function( pOption ){
                                        tb.dom( &#x27;option[value=&quot;&#x27; + pOption + &#x27;&quot;]&#x27;, that )
                                            .selected = true;
                                    }
                                );

                        }
                        
                        return;
                    },

                    &#x27;default&#x27;: function defaultVal( pValue ){

                        var that = this,
                            ret;

                        if ( that.type === &#x27;radio&#x27; ){ // input radio or checkbox
                            var name = that.name,
                                selector = &#x27;[type=&quot;radio&quot;][name=&quot;&#x27; + name + &#x27;&quot;]&#x27;,
                                radios = tb.dom( that ).parents( &#x27;form&#x27; ).descendants( selector );

                            ret = &#x27;&#x27;;

                            radios
                                .forEach(
                                    function( pRadio ){
                                        var isElement;

                                        if ( typeof pValue !== &#x27;undefined&#x27; ){ // setter
                                            isElement = pRadio.value === pValue;

                                            pRadio.checked = isElement ? true : false;

                                            ret = pRadio.checked ? pRadio.value : ret;
                                        } else { // getter
                                            if ( pRadio.checked === true ){
                                                ret = pRadio.value;
                                            }
                                        }

                                    }
                                );

                            return ret;

                        }

                        if ( that.type === &#x27;checkbox&#x27; ){ // input radio or checkbox

                            if ( typeof pValue !== &#x27;undefined&#x27; ){ // setter
                                that.checked = pValue ? true : false;
                                ret = that.checked;
                            } else { // getter
                                ret = false;
                                if ( that.checked === true ){
                                    ret = true;
                                }
                            }

                            return ret;

                        } else { // not a radio or checkbox

                            if ( !arguments.length ) { // getter

                                ret = that.value;

                                return typeof ret === &quot;string&quot; ?
                                    ret :
                                    ret == null ? &quot;&quot; : ret;

                            } else { // setter

                                // Treat null/undefined as &quot;&quot;; convert numbers to string
                                if (pValue == null) {
                                    pValue = &quot;&quot;;
                                } else if (typeof val === &quot;number&quot;) {
                                    pValue += &quot;&quot;;
                                }

                                that.value = pValue;

                            }

                        }

                    }

                };

                if ( arguments.length ){

                    that.forEach(
                        function ( pElement ) {

                            if ( !isInput( pElement ) ){
                                return; // not an input element
                            }

                            ret = !!valHandlers[ pElement.tagName.toLowerCase() ]
                                ? valHandlers[ pElement.tagName.toLowerCase() ].call( pElement, pValue )
                                : valHandlers[ &#x27;default&#x27; ].call( pElement, pValue );

                        }
                    );

                    return that;

                } else { // getter

                    that.some(
                        function ( pElement ) {

                            if ( !isInput( pElement ) ){
                                return false; // is not an input element
                            }

                            ret = !!valHandlers[ pElement.tagName.toLowerCase() ]
                                ? valHandlers[ pElement.tagName.toLowerCase() ].call( pElement )
                                : valHandlers[ &#x27;default&#x27; ].call( pElement );

                            return true; // is an input element

                        }
                    );

                }

                return ret;
            }

            /**
             @method values

             @param {object} [pValues] - field values

             @return {object} - an object containing all values of a forms input fields

             get or set all form input values
             */
            function values(pData) {

                var that = this,
                    node = that[0] || undefined,
                    values,
                    observable;

                if ( !node ) { // nothing found
                    return that;
                }

                // it is a hash object -&gt; treat as setter
                if ( typeof pData === &#x27;object&#x27; &amp;&amp; !!node ){ 
                    var v = tb.dom( node ).values();

                    Object
                        .keys( pData )
                        .forEach(function( pKey ){
                            if ( v.hasOwnProperty( pKey ) ){
                                v[pKey] = pData[ pKey ];
                            }
                        });

                    return;
                }

                // not processed yet
                if ( !node[&#x27;getValues&#x27;] ){
                    // form changed observable
                    node[&#x27;getValues&#x27;] = tb.observable({});

                    // create form change binding
                    tb.dom(&#x27;input,select,textarea&#x27;, node)
                        .on(
                            &#x27;keyup change select&#x27;,
                            tb.debounce( function onFormChange(){
                                //console.log(&#x27;keyup change select&#x27;);
                                node[&#x27;getValues&#x27;]( tb.extend( {}, tb.dom(node).values() ) );
                            }, 5 )
                        );
                }

                // form setter observable
                node[&#x27;values&#x27;] = !!node[&#x27;values&#x27;] ? node[&#x27;values&#x27;] : tb.observable({});

                // value hash constructor
                function Values(){
                }

                // value hash prototype
                Values.prototype = {
                    bind: function( pObject, pOnce ){
                        //console.log(&#x27;bind&#x27;, pObject, pOnce, node[&#x27;getValues&#x27;]() );
                        
                        node[&#x27;getValues&#x27;].observe(function changeTarget(){
                            //console.log(&#x27;formvalues changed -&gt; set object&#x27;, pObject, node[&#x27;getValues&#x27;]() );
                            tb.extend( pObject, node[&#x27;getValues&#x27;]() );
                            setTimeout(function(){
                                if(!!Object.getOwnPropertySymbols(pObject)[1]){
                                    pObject[Object.getOwnPropertySymbols(pObject)[1]](); // onChange debounced function
                                }
                            }, 0);
                        }, pOnce);
                        
                        node[&#x27;getValues&#x27;].notify(); // push initial setting
                    },

                    observe: function( pCallback, pOnce ){
                        node[&#x27;values&#x27;].observe( pCallback, pOnce );
                    }
                };

                // make value hash
                values = new Values();

                Object.defineProperty(
                    that,
                    &#x27;values&#x27;,
                    {
                        enumerable: true,

                        configurable: true,

                        set: function( pObject ){

                            // disable notifications for bulk change
                            node[&#x27;values&#x27;]
                                .enableNotify( false );

                            Object
                                .keys( pObject )
                                .forEach(
                                    function( pKey ){
                                        that.values[ pKey ] = pObject[ pKey ];
                                    }
                                );

                            // now notify
                            node[&#x27;values&#x27;]
                                .enableNotify()
                                .notify();

                        },

                        get: (function(node, observable){ return function(){
                            var fields = tb.dom(&#x27;input[name],select[name],textarea[name]&#x27;, node );

                            fields
                                .forEach(
                                    function( pField ){
                                        var key = tb.dom( pField ).attr(&#x27;name&#x27;);

                                        if ( values.hasOwnProperty( key ) ){
                                            return;
                                        }

                                        Object.defineProperty(
                                            values,
                                            key,
                                            {
                                                enumerable: true,

                                                get: function(){
                                                    return tb.dom( pField ).val();
                                                },
                                                set: function( pValue ){
                                                    var ret = tb.dom( pField ).val( pValue );

                                                    observable( values );

                                                    return ret;
                                                }
                                            }
                                        );

                                    }
                                );

                            // set observable w/ values
                            node[&#x27;values&#x27;]( values );

                            return values;

                        };})( node, node[&#x27;values&#x27;] )
                    }
                );

                return that.values;
            }


            return {
                add: add,
                addClass: addClass,
                append: append,
                appendTo: appendTo,
                attr: attr,
                children: children,
                clean: clean,
                descendants: descendants,
                empty: empty,
                filter: filter,
                first: first,
                hasClass: hasClass,
                hide: hide,
                html: html,
                insertBefore: insertBefore,
                insertAfter: insertAfter,
                last: last,
                next: next,
                not: not,
                off: off,
                on: on,
                one: one,
                parent: parent,
                parents: parents,
                previous: previous,
                remove: remove,
                removeAttr: removeAttr,
                removeClass: removeClass,
                show: show,
                toArray: toArray,
                toggleClass: toggleClass,
                trigger: trigger,
                unique: unique,
                val: val,
                values: values
            };
        })();

        dom.prototype = tb.extend( dom.methods, dom.arrayMethods );

        f = function (pSelector, pDomNode) {

            return new dom( pSelector, pDomNode );
        };

        f.innerProto = dom.prototype;

        return f;
    })();

    tb.dom.plugin = function( pMethodName, pFunction ){
        var p = tb.dom.innerProto;

        if ( !p[ pMethodName ] ){
            p[ pMethodName ] = pFunction;
        } else {
            console.warn( &#x27;tb.dom.plugin(): Cannot overload existing tb method (&#x27;, pMethodName, &#x27;)&#x27; );
        }

    };

}


/**
 @class tb.Util

 @description
     placeholder class, everything contained herein is a curry property of the tb() constructor
 */

/**
 an empty function just in case you need one

 @memberof tb
 @static
 @method tb.nop

 @example

     // this is not very useful, but alas...
     // append the empty function to the &#x27;click&#x27; event handler list
     this.on(&#x27;click&#x27;, tb.nop);
 */
tb.nop = function(){};

/**
 @memberof tb
 @method tb.namespace
 @static
 @chainable

 @param {string} pNamespace
 @param {object} [pObject] object to scan

 @return {object} containing set() / get() functions for property in pNamespace

 @example

     // lookup [window] namespace:
     tb.namespace( &#x27;test.GrandParent&#x27; ); // gets the constructor for the GrandParent from DOM

     // in a constructor force namespace creation:
     tb.namespace( &#x27;app.prop&#x27; ).set( &#x27;testVal&#x27; );     // force creation of &#x27;app.prop&#x27; if it doesnt exist, set value to &#x27;testVal&#x27;

 @example

     // lookup namespace in any object and return value:
     tb.namespace( &#x27;x.y&#x27;, { x: { y: 42 } } ).get();     // 42

 @example

     // create content in any object as denominated by namespace:
     var obj = { x: { y: 42 } }
     tb.namespace( &#x27;x.z&#x27;, obj ).set( 43 );     // obj =&gt; { x: { y: 42, z: 43 } }

 */
tb.namespace = (function(){

    // constructor
    function Namespace( pNamespace, pObject){
        var that = this;

        that.namespace = pNamespace;
        that.target = pObject;
        that.namespaceArray =  pNamespace.indexOf( &#x27;.&#x27; ) ? pNamespace.split(&#x27;.&#x27;) : [ pNamespace ];
        that.forceCreation = false;
    }

    // prototype
    Namespace.prototype = {
        get: get,
        set: set,
        _walk: _walk
    };

    return function ( pNamespace, pObject ){
        return new Namespace( pNamespace, pObject );
    };

    // methods
    function _walk( o, namespaceArray ) {
        var that = this;

        if ( !o[ namespaceArray[0] ] &amp;&amp; !!this.forceCreation ) {
            o[ namespaceArray[0] ] = {};
        }

        if ( namespaceArray.length &lt; 2 ){

            if( that.forceCreation &amp;&amp; typeof that.value !== &#x27;undefined&#x27; ){ // if value is present it is called with set()
                o[ namespaceArray[0] ] = that.value;
            }
            return o.hasOwnProperty( namespaceArray[0] ) ? o[ namespaceArray[0] ] : undefined;

        } else {

            if ( o.hasOwnProperty( namespaceArray[0] ) ) {
                o = o[ namespaceArray[0] ];
                namespaceArray.shift();
                return that._walk( o, namespaceArray );
            } else {
                return;
            }

        }
    }

    function get(){
        var that = this;

        that.forceCreation = false;
        return that._walk( !that.target ? window : that.target, that.namespaceArray );
    }

    function set( pValue ){
        var that = this;

        if ( typeof pValue === &#x27;function&#x27; 
            &amp;&amp; pValue.prototype !== Function.prototype //jshint ignore:line
        ){ //it is a custom class
            pValue.prototype.namespace = that.namespace;
        }

        that.value = pValue;
        that.forceCreation = true;

        return that._walk( !that.target ? window : that.target, that.namespaceArray );
    }

})();

/**
 @memberof tb
 @static
 @method tb.attach

 @param  {object} [pRootNode] DOM node to start binding in
 
 @example

     tb.attach( document.body );
     // scans the given element and all of its descendants
     // in the DOM and looks for attributes &quot;data-tb&quot; in the nodes.

     // Resulting list will be scanned for those nodes that do not already
     // have a tb object inside which is given as a namespace in the data-tb attribute.

     // Creates missing tb object based on the class namespace given
     // in the &quot;data-tb&quot; attribute and stores it in the DOM element
    
 */
tb.attach = function( pRootNode ){

    var rootNode = pRootNode || document.body,
        foundElements = tb.dom( rootNode.querySelectorAll( &#x27;[data-tb]&#x27; ) ).toArray();

    // add self if data-tb attribute present
    if ( rootNode.getAttribute(&#x27;data-tb&#x27;) ){
        foundElements = [rootNode].concat( foundElements );
    }

    // instanciate tb instances for given elements
    foundElements.forEach(
        function( pElement ){
            var namespaces = pElement.getAttribute(&#x27;data-tb&#x27;).split(&#x27; &#x27;);

            namespaces.forEach(
                function( pNamespace ){
                    pElement[&#x27;tb&#x27;] = pElement[&#x27;tb&#x27;] || {};
                    if ( !pElement[&#x27;tb&#x27;][pNamespace] ){
                        new tb(        // create tb object
                            pNamespace,
                            null,
                            pElement
                        );
                    }
                }
            );

        }
    );

};

/**
 returns a unique id

 @memberof tb
 @static
 @method tb.getId

 @return {string} - unique id

 */
tb.getId = function(){
    return &#x27;id-&#x27; + (new Date()).getTime() + &#x27;-&#x27; + Math.random().toString().replace(/\./, &#x27;&#x27;);
};

/**
 - Promise/A+ compliant promise functionality

 @memberof tb
 @static
 @class tb.Promise
 @constructor

 @param {function} pFunction function to execute
 
 @return {object} Promise/A+ compliant promise object

 @example

        var p = new tb.Promise(function(resolve, reject){

            setTimeout(function(){
                resolve(&#x27;it worked.&#x27;);
            },1000)

            setTimeout(function(){
                reject(&#x27;something went wrong.&#x27;);
            },500)

        }).then(function(pValue){

            console.log(&#x27;Yippie! &#x27;, pValue);

        }).catch(function(pValue){

            console.log(&#x27;Oops? &#x27;, pValue);

        }).finally(function(pValue){

            console.log(&#x27;Cleaning up &#x27;, pValue);

        });

 */
tb.Promise = (function(){

    &#x27;use strict&#x27;;

    var LAST_ERROR = null;
    var IS_ERROR = {};

    // Promise constructor
    function Promise(fn) {
        fn = fn || tb.nop;
        if (typeof this !== &#x27;object&#x27;) {
            throw new TypeError(&#x27;Promises must be constructed via new&#x27;);
        }
        this._deferredState = 0;
        this._state = 0;
        this._value = null;
        this._deferreds = null;
        if (fn === tb.nop) {
            return;
        }
        doResolve(fn, this);
    }
    Promise._onHandle = null;
    Promise._onReject = null;

    // Promise prototype
    Promise.prototype = {
        /**
         @method then
         @chainable

         @param {function} pFunction - function to execute when promise is resolved

         @return {object} - a new Promise instance (chaining)


         @example

                new tb.Promise(function(resolve, reject){
                    setTimeout( resolve(&#x27;ok.&#x27;) );
                }).then(function(pValue){
                    console.log( pValue );  // &gt;ok.
                });

         */
        then: _then,

        /**
         @method catch
         @chainable

         @param {function} pFunction - function to execute when promise is rejected

         @return {object} - a new Promise instance (chaining)


         @example

                new tb.Promise(function(resolve, reject){
                    setTimeout( reject(&#x27;oops.&#x27;) );
                }).catch(function(pValue){
                    console.log( pValue );  // &gt;oops.
                });

         */
        &#x27;catch&#x27;: _catch,

        /**
         @method finally
         @chainable

         @param {function} pFunction - function to execute at the end in any case

         @return {object} - a new Promise instance (chaining)


         @example

                new tb.Promise(function(resolve, reject){
                    setTimeout( reject(&#x27;whatever.&#x27;) ); // could also be resolve, finally will always be executed
                }).finally(function(pValue){
                    console.log( pValue );  // &gt;whatever.
                });

         */
        &#x27;finally&#x27;: _finally,

        done: _done
    };

    // static methods

    /**
     @method tb.Promise.resolve
     @chainable
     @static

     @param {any} pValue - the value the returned promise will resolve with

     @return {object} - a new resolved Promise instance (chaining)


     @example

            var p = tb.Promise.resolve(&#x27;resolved&#x27;);

     */
    Promise.resolve = function( pValue ){
        var ret = new tb.Promise(function( resolve, reject ){
        });

        resolve( ret, pValue );

        return ret;
    };

    /**
     @method tb.Promise.reject
     @chainable
     @static

     @param {any} pValue - the value the returned promise will reject with

     @return {object} - a new rejected Promise instance (chaining)


     @example

            var p = tb.Promise.reject(&#x27;rejected&#x27;);

     */
    Promise.reject = function( pValue ){
        var ret = new tb.Promise(function( resolve, reject ){
        });

        reject( ret, pValue );

        return ret;
    };

    /**
     @method tb.Promise.all
     @chainable
     @static

     @param {array} pIterable - an array containing values and/or promises

     @return {object} - a new rejected Promise instance (chaining)

     @example

            // &quot;then&quot; function will be executed when ALL promises have been resolved
            // &quot;catch&quot; function will be executed if one of the promises rejects
            // values in the parameter array will be converted to Promise.resolve(value)

             var p = tb.Promise.all([
                 true,
                 tb.Promise.resolve(&#x27;new value&#x27;)
             ]).finally(function(pValue){
                console.log(pValue); // &gt;[ true, &#x27;new value&#x27; ]
             });

             var p = tb.Promise.all([
                 true,
                 tb.Promise.reject(&#x27;oops.&#x27;)
             ]).finally(function(pValue){
                console.log(pValue); // &gt;oops.
             });
     */
    Promise.all = function( pIterable ){

        var count = pIterable.length,
            observable = tb.observable(count),
            promise = new Promise(),
            result = new Array(count);

        // convert to promises if necessary and add callbacks
        pIterable
            .forEach( function( pValue, pIndex ){

                if ( !pValue.then || typeof pValue.then !== &#x27;function&#x27; ){
                    pValue = tb.Promise.resolve( pValue );
                }
                  
                pValue
                    .then(function(pValue){
                        result[ pIndex ] = pValue;
                    })
                    .catch(function(pValue){
                        if ( promise._state === 0 ){
                            reject( promise, pValue._value );
                        }
                    })
                    .finally(function(pValue){
                        observable( observable() - 1 );
                    });

            });

        observable.observe(function(pValue){
            if ( pValue === 0 ){
                observable = null;
                if ( promise._state === 0 ){
                    resolve( promise, result );
                }
            }
        });

        return promise;
    };

    /**
     @method tb.Promise.race
     @chainable
     @static

     @param {array} an array containing values and/or promises

     @return {object} a new rejected Promise instance (chaining)

     @example

            // &quot;then&quot; function will be executed when the fastest promise resolves
            // &quot;catch&quot; function will be executed when the fastest promise rejects
            // values in the parameter array will be converted to Promise.resolve(value)

            var p1 = new tb.Promise(function(resolve,reject){
                setTimeout(function(){
                    resolve(&#x27;ok.&#x27;);
                },1000);
            });

            var p2 = new tb.Promise(function(resolve,reject){
                setTimeout(function(){
                    reject(&#x27;oops.&#x27;);
                },2000);
            });

            var p = tb.Promise.race([
                p1,
                p2
            ]).then(function(pValue){
                console.log(pValue); // &gt;ok.
            }).catch(function(pValue){
                console.log(pValue); // (will never be reached, p1 resolves first)
            });
     */
    Promise.race = function( pIterable ){
        var promise = new tb.Promise();

        // convert to promises if necessary and add callbacks
        pIterable
            .forEach( function( pValue, pIndex, pOriginalIterable ){
                if ( pValue.constructor !== Promise ){
                    pOriginalIterable[ pIndex ] = Promise.resolve( pValue );
                }
                
                pOriginalIterable[ pIndex ]
                    .then(function(pValue){
                        if ( promise._state === 0 ){
                            resolve( promise, pValue );
                        }
                    })
                    .catch(function(pValue){
                        if ( promise._state === 0 ){
                            reject( promise, pValue );
                        }
                    });
            });

        return promise;
    };

    return Promise;

    // private functions

    // HINT: ignore:lines are needed because jslint regards these functions as being standalone,
    // which they are not - they are the implementation of Promise.prototype methods.

    function _then(onFulfilled, onRejected) {
        if ( !( this instanceof Promise) ) { // jshint ignore:line
            return safeThen(this, onFulfilled, onRejected); // jshint ignore:line
        }
        var res = new Promise(tb.nop);
        handle(this, new Handler(onFulfilled, onRejected, res)); // jshint ignore:line
        return res;
    }

    function _catch( pFunction ){
        return this.then( null, pFunction ); // jshint ignore:line
    }

    function _done(onFulfilled, onRejected) {
        var that = arguments.length ? this.then.apply(this, arguments) : this; // jshint ignore:line
        that.then(null, function (pValue) {
            setTimeout(function () {
                throw pValue;
            }, 0);
        });
    }

    function _finally(f) {
        var that = this; // jshint ignore:line

        return this.then(function (pValue) { // jshint ignore:line
            return Promise.resolve(f(that._value)).then(function () {
                return that._value;
            });
        }, function (pValue) {
            return Promise.resolve(f(that._value)).then(function () {
                throw that._value;
            });
        });
    }

    function getThen(obj) {
        try {
            return obj.then;
        } catch (e) {
            LAST_ERROR = e;
            return IS_ERROR;
        }
    }

    function tryCallOne(fn, a) {
        try {
            return fn(a);
        } catch (e) {
            LAST_ERROR = e;
            return IS_ERROR;
        }
    }
    function tryCallTwo(fn, a, b) {
        try {
            fn(a, b);
        } catch (e) {
            LAST_ERROR = e;
            return IS_ERROR;
        }
    }

    function safeThen(that, onFulfilled, onRejected) {
        return new that.constructor(function (resolve, reject) {
            var res = new tb.Promise(tb.nop);
            res.then(resolve, reject);
            handle(that, new Handler(onFulfilled, onRejected, res));
        });
    }

    function handle(that, deferred) {
        while (that._state === 3) {
            that = that._value;
        }
        if (Promise._onHandle) {
            Promise._onHandle(that);
        }
        if (that._state === 0) {
            if (that._deferredState === 0) {
                that._deferredState = 1;
                that._deferreds = deferred;
                return;
            }
            if (that._deferredState === 1) {
                that._deferredState = 2;
                that._deferreds = [that._deferreds, deferred];
                return;
            }
            that._deferreds.push(deferred);
            return;
        }
        handleResolved(that, deferred);
    }

    function handleResolved(that, deferred) {
        setTimeout( function() {
            var cb = that._state === 1 ? deferred.onFulfilled : deferred.onRejected;
            if (cb === null) {
                if (that._state === 1) {
                    resolve(deferred.promise, that._value);
                } else {
                    reject(deferred.promise, that._value);
                }
                return;
            }
            var ret = tryCallOne(cb, that._value);
            if (ret === IS_ERROR) {
                reject(deferred.promise, LAST_ERROR);
            } else {
                resolve(deferred.promise, ret);
            }
        }, 0);
    }

    function resolve(that, newValue) {
        // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
        if (newValue === that) {
            return reject(
                that,
                new TypeError(&#x27;A promise cannot be resolved with itself.&#x27;)
            );
        }
        if (
            newValue &amp;&amp;
            (typeof newValue === &#x27;object&#x27; || typeof newValue === &#x27;function&#x27;)
        ) {
            var then = getThen(newValue);
            if (then === IS_ERROR) {
                return reject(that, LAST_ERROR);
            }
            if (
                then === that.then &amp;&amp;
                newValue instanceof Promise
            ) {
                that._state = 3;
                that._value = newValue;
                finale(that);
                return;
            } else if (typeof then === &#x27;function&#x27;) {
                doResolve(then.bind(newValue), that);
                return;
            }
        }
        that._state = 1;
        that._value = newValue;
        finale(that);
    }

    function reject(that, newValue) {
        that._state = 2;
        that._value = newValue;
        if (Promise._onReject) {
            Promise._onReject(that, newValue);
        }
        finale(that);
    }
    function finale(that) {
        if (that._deferredState === 1) {
            handle(that, that._deferreds);
            that._deferreds = null;
        }
        if (that._deferredState === 2) {
            for (var i = 0; i &lt; that._deferreds.length; i++) {
                handle(that, that._deferreds[i]);
            }
            that._deferreds = null;
        }
    }

    function Handler(onFulfilled, onRejected, promise){
        this.onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : null;
        this.onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : null;
        this.promise = promise;
    }

    /**
     * execute promise function
     */
    function doResolve(fn, promise) {
        var done = false;
        var res = tryCallTwo(fn, function (value) {
            if (done) {
                return;
            }
            done = true;
            resolve(promise, value);
        }, function (reason) {
            if (done) {
                return;
            }
            done = true;
            reject(promise, reason);
        });
        if (!done &amp;&amp; res === IS_ERROR) {
            done = true;
            reject(promise, LAST_ERROR);
        }
    }

})();

/**
 @memberof tb
 @static
 @class tb.Require
 @constructor

 @param {(string|string[])} pRequiredFiles string or string array containing required files

 @return {object} Promise/A+ compliant promise object

 tb.Require class ( uses tb.require function and returns the promise returned by it )

 - add into prototype of your constructor
 - instance will get an &#x27;init&#x27; event when all files have loaded.

 @example

     tb.namespace( &#x27;app.GrandParent&#x27; ).set( 
         (function(){

              // Constructor
              function GrandParent(){
                  var that = this;
    
                  that.handlers = {
                      init
                  };
    
              }
    
              // Prototype
              GrandParent.prototype = {
    
                  namespace: &#x27;app.GrandParent&#x27;,
    
                  &#x27;tb.Require&#x27;: [
                       &#x27;/app/GrandParent.css&#x27;
                  ]
    
              };
    
              return GrandParent;
    
              // Private Methods
    
              function init(){
                   // will be called when requirement loading is finished ( both success and error )
              }
    
         })()
     );
 */
tb.Require = function ( pFiles ) {
    return tb.require( pFiles );
};

tb.Require.prototype = {};


/**
 @memberof tb
 @static
 @method tb.require

 @param {(string|string[])} pFiles array of filenames
 @param {function} [pCallback] optional callback after all loading is done
 
 @return {object} - Promise/A+ compliant promise object

 @example

        // in your code ...
        tb.require([
            &#x27;/app/styles.css&#x27;,                  // .css will be inserted into head &lt;link&gt;
            &#x27;/app/someJavascript.js&#x27;,           // .js will be inserted into head &lt;script&gt;
            &#x27;/app/someData.json&#x27;,               // .json data will be parsed to JS object
            &#x27;/app/templates/someTemplate.html&#x27;  // all other file contents will be saved into repo
        ], function( pValue ){
            // do something when all loading activity has finished
            console.log(pValue); // &gt;[ &#x27;done&#x27;, &#x27;done&#x27;, &lt;someObject&gt;, &#x27;&lt;someHtmlString&gt;&#x27; ]
        });
 
 */
tb.require = function( pFiles, pCallback ){

    var promiseArray = [], // used for Promise.all()
        ret;

    //console.log( &#x27;tb.require()&#x27;, pFiles);

    if ( !pFiles ){
        var warn = &#x27;tb.require: no files given.&#x27;;

        console.warn(warn);

        return tb.Promise.reject(warn);
    }

    // convert to array anyway
    if ( typeof pFiles === &#x27;string&#x27; ){
        pFiles = [ pFiles ];
    }

    // make parameter array for tb.Promise.all
    pFiles
        .forEach(function( pFile ){
            var type = _getTypeFromSrc( pFile );

            if ( pFile.split(&#x27;/&#x27;).pop().indexOf(&#x27;.&#x27;) === -1 ){ // file type extension
                var warn = &#x27;tb.require: no file type given for &#x27;;

                console.warn( warn, pFile );

                return tb.Promise.reject( warn + pFile );
            }

            // file type container does not exist
            if ( !tb.require.repo[type] ){
                tb.require.repo[type] = {};
            }

            // file promise does not exist in container
            if ( !tb.require.repo[type][pFile] ){
                // if on client, load from server, if on server, load from file system
                tb.require.repo[type][pFile] = typeof module === &#x27;undefined&#x27; ? _load( pFile ) : _fsLoad( pFile );
            }

            // finally push promise
            promiseArray.push( tb.require.repo[type][pFile] );

        });


    ret = tb.Promise.all(promiseArray);

    // attach callback if given
    if ( !!pCallback ){
        ret.finally( function(pValueArray){
            pCallback.call( pValueArray );
        });
    }

    return ret;

    // private functions

    function _fsLoad(pFile){
        
        var fs = require(&#x27;fs&#x27;),
            type = _getTypeFromSrc(pFile),
            content,
            promise;

        promise = new tb.Promise(function(resolve, reject){

            var file = pFile;

            // we resolve all loading operations even if they fail, 
            // because failure shouldnt halt operations
            // in case of failure result value will be an error message
            if ( type === &#x27;js&#x27; ){
                try {
                    require(file);
                    resolve(&#x27;done.&#x27;);
                } catch (e) {
                    resolve(&#x27;error reading file using require(&quot;&#x27; + file + &#x27;&quot;&quot;)&#x27;);
                }
            } else {
                if ( fs.existsSync( file ) ){
                    try {
                        content = fs.readFileSync( file, &#x27;utf8&#x27; );
                        resolve(content);
                    } catch (e) {
                        resolve( &#x27;error: could not read file [&#x27; + file + &#x27;]&#x27;);
                    }

                } else {
                    resolve(&#x27;error: file not found [&#x27; + file + &#x27;]&#x27;);
                }
            }

        }).finally(function(pValue){

            tb.require.repo[type][pFile] = pValue;
        
        });

        return promise;

    }

    function _load(pFile){
        
        var typeConfigs = { // standard configuration types
                &#x27;css&#x27;: {
                    tag: &#x27;link&#x27;,
                    attributes: {
                        type: &#x27;text/css&#x27;,
                        rel: &#x27;stylesheet&#x27;,
                        href: &#x27;{src}&#x27;
                    }
                },
                &#x27;js&#x27;: {
                    tag: &#x27;script&#x27;,
                    attributes: {
                        type: &#x27;text/javascript&#x27;,
                        src: &#x27;{src}&#x27;
                    }
                }
            },
            typeConfig,
            type = _getTypeFromSrc(pFile),
            file = pFile,
            promise;

        // cache busting
        if ( !!tb.require.cacheBust ){ // temporarily disabled
            //file = pFile + ( pFile.indexOf(&#x27;?&#x27;) &gt; -1 ? &#x27;&amp;&#x27; : &#x27;?&#x27; ) + tb.getId();
        }

        //console.log(&#x27;load&#x27;, type, typeConfigs);

        // do loading
        if ( !!typeConfigs[type] ) { // either *.css or *.js file

            // increase loadcount ( tb.idle() related )
            tb.status.loadCount(tb.status.loadCount() + 1); // increase loadCount

            promise = new tb.Promise(function(resolve, reject){
                var element;

                //console.log(&#x27;special load&#x27;, type, typeConfigs);

                // get default config for type
                typeConfig = typeConfigs[type];

                // create DOM element
                element = document.createElement(typeConfig.tag);
                element.async = true;
                element.onreadystatechange = element.onload = function () {
                    var state = element.readyState;
                    if ( !state || /loaded|complete/.test(state) ) {
                        resolve(&#x27;1&#x27;);
                    }
                };

                // add attributes to DOM element
                Object
                    .keys( typeConfig.attributes )
                    .forEach(
                        function( pKey ){
                            element.setAttribute(pKey, tb.parse(typeConfig.attributes[pKey], { src: pFile }));
                        }
                    );

                // append node to head
                document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(element);

            }).finally(function(){

                // decrease loadcount ( tb.idle() related )
                tb.status.loadCount(tb.status.loadCount() - 1); // increase loadCount

                tb.require.repo[type][pFile] = &#x27;done&#x27;;
            
            });

            return promise;

        } else { // load via request if unknown type, trigger callback with text or JSON

            var f = function (data) {

                // convert if .json
                if ( type === &#x27;json&#x27; &amp;&amp; !!data[&#x27;text&#x27;]) {
                    try {
                        tb.require.repo[type][pFile] = JSON.parse(data.text);
                    } catch (e) {
                        console.error(&#x27;invalid JSON: &#x27;, data);
                    }
                } else {
                    tb.require.repo[type][pFile] = data.text;
                }

            };

            var options = {
                url: file
            };

            return tb.request(options).finally(f);

        }

    }

    function _getTypeFromSrc(pSrc) {
        return pSrc.split(&#x27;?&#x27;)[0].split(&#x27;.&#x27;).pop();
    }

};

tb.require.repo = {};
tb.require.cacheBust = true;
tb.require.loadcount = 0;

tb.require.get = function(pFile){
    let extension = pFile.split(&#x27;?&#x27;)[0].split(&#x27;.&#x27;).pop();
    if (tb.require.repo[extension]){
        return tb.require.repo[extension][pFile] || undefined;
    }
    return false;
};

/**
 @memberof tb
 @static
 @method tb.webSocket

 @param pOptions { object } a hash object containing these options:

 @param {string} pOptions.url - the URL to call
 @param {array} [pOptions.protocols] - array containing protocol names the server can choose from

 @return {object} - a twoBirds compliant websocket implementation

 @example

        // hint: you must use ws:// from http:// apps, and wss:// from https:// apps
        var ws = tb.webSocket(
            &#x27;ws://localhost:8000&#x27;
        ).on(
            &#x27;error&#x27;,
            function(){
                console.error( &#x27;error establishing connection&#x27; );
            }
        ).on(
            &#x27;open&#x27;,
            function(){
                console.log( &#x27;connection opened&#x27; );
            }
        ).on(
            &#x27;close&#x27;,
            function(){
                console.log( &#x27;connection closed&#x27; );
            }
        ).on(
            &#x27;message&#x27;,
            function( pMessage ){
                console.log( pMessage );
            }
        );

        ws.send(JSON.stringify( { id: tb.getId(), msg: &#x27;Hallo&#x27; } ));

        ws.close();

 */
tb.webSocket = (function () {

    function WS( pConfig ){
        var that = this;

        that.config = pConfig;

        that.socket = !!that.config[&#x27;protocols&#x27;]
            ? new WebSocket( // jshint ignore:line
                that.config.url, 
                that.config[&#x27;protocols&#x27;]
            )
            : new WebSocket( // jshint ignore:line
                that.config.url 
            );

        that.socket.onopen = function onOpen( ev ){
            that.trigger( &#x27;open&#x27;, ev );
        };
        
        that.socket.onerror = function onError( ev ){
            that.trigger( &#x27;error&#x27;, ev );
        };
        
        that.socket.onmessage = function onMessage( ev ){
            that.trigger( &#x27;message&#x27;, ev.data );
        };
        
        that.socket.onclose = function onClose( ev ){
            that.trigger( &#x27;close&#x27;, ev );
        };
               
    } 

    WS.prototype = {
        send: send,
        close: close
    };

    return function( pUrl, pProtocols ){
        return new tb( 
            WS, 
            { 
                url: pUrl,
                protocols: pProtocols
            }
        );
    };
    
    function send(pSend) {
        this.socket.send(pSend);
    }

    function close() {
        this.socket.close();
    }

})();

/**
 @memberof tb
 @static
 @method tb.request

 @param pOptions { object } a hash object containing these options:&lt;br&gt;&lt;br&gt;&lt;br&gt;

 @param pOptions.url: (string, required) the URL to call
 @param {object} [pOptions.params] - a hash object containing the parameters to post
 @param {string} [pOptions.method] - (string, optional, defaults to &#x27;POST&#x27;) the XHR method
 @param {object} [pOptions.headers] - a hash object containing additional XHR headers
 @param {function} [pOptions.success] - the function to call with the request result
 @param {function} [pOptions.error] - the function to call if request status not in 200...299
 @param {function} [pOptions.statechange] - the function to call when readyState changes
 @param {number} [pOptions.timeout] - structure sample: { cb: myFunction, ms:10000 }
    cb: callback to run when timeout occurs
    ms: number of milliseconds the request will run before being terminated
 @param {boolean} [pOptions.cachable] - defaults to true, indicates whether or not to include a unique id in URL
 @param {boolean} [pOptions.async] - defaults to true, indicates whether or not to make an asynchronous request

 @return {object} - a Promise/A+ compliant promise object

 */
if (typeof module === &#x27;undefined&#x27; ){
    tb.request = (function () {
        /** @private */
        var loadlist = [],
            readyState = &#x27;complete&#x27;,
            cachable = false,
            log = false,
            count = 0,
            interval = 30,
            msoft = [&#x27;Msxml2.XMLHTTP&#x27;, &#x27;Microsoft.XMLHTTP&#x27;];

        function getConnection(pId) {
            var obj,
                xhr,
                getConnection;

            if (typeof ActiveXObject !== &#x27;undefined&#x27;){
                for (var i = 0; i &lt; msoft.length; ++i) {
                    try {
                        xhr = new ActiveXObject(msoft[i]);

                        obj = {
                            connection: xhr,
                            identifier: pId
                        };

                        /* jshint ignore:start */
                        getConnection = (function (pType) {
                            return function (pId) {
                                var xhr = new ActiveXObject(pType);
                                obj = {
                                    connection: xhr,
                                    identifier: pId
                                };
                                return obj;
                            };
                        })(msoft[i]);
                        /* jshint ignore:end */

                    } catch (e) {
                    }
                }
            }

            try {
                xhr = new XMLHttpRequest();
                obj = {
                    connection: xhr,
                    identifier: pId
                };
                /** @ignore */
                getConnection = function (pId) {
                    var xhr = new XMLHttpRequest();
                    obj = {
                        connection: xhr,
                        identifier: pId
                    };
                    return obj;
                };
            }
            catch (e) {
            }
            finally {
                return obj;
            }
        }

        /** @private */
        function handleReadyState(pReq, pResolve, pStateChange, pReject, pOptions) {
            var connection = this;
            var poll = window.setInterval((function (pReadyState) {
                return function () {
                    if (pReq.connection.readyState !== pReadyState) {
                        pReadyState = pReq.connection.readyState;
                        //pStateChange();
                    }
                    if (pReadyState === 4) {
                        if (pReq.aborttimer) {
                            window.clearTimeout(pReq.aborttimer);
                        }
                        window.clearInterval(poll);
                        handleTransactionResponse(pReq, pResolve, pReject, pOptions);
                    }
                };
            })(0), interval);

            return poll;
        }

        /** @private */
        function handleTransactionResponse(pReq, pResolve, pReject, pOptions) {
            var httpStatus,
                responseObject;

            try {
                httpStatus = pReq.connection.status;
            }
            catch (e) {
                httpStatus = 13030;
            }

            if (httpStatus &gt;= 200 &amp;&amp; httpStatus &lt; 400) {
                responseObject = createResponseObject(pReq, pOptions);
                try {
                    pResolve( responseObject );
                }
                catch (e) {
                    if (tb.debug){
                        debugger;
                    }
                }
            }
            else {
                responseObject = createResponseObject(pReq, tb.extend( {}, pOptions ) );
                pReject( responseObject );
            }
            release(pReq);
        }

        /** @private */
        function createResponseObject(pObj, pOptions) {
            var obj = {
                tId: pObj.identifier,
                status: pObj.connection.status,
                statusText: pObj.connection.statusText,
                responseHeaders: {},
                requestHeaders: pOptions.headers,
                text: pObj.connection.responseText,
                xml: pObj.connection.responseXML,
                options: pOptions
            };

            pObj
                .connection
                .getAllResponseHeaders()
                .split(&#x27;\r\n&#x27;)
                .forEach(function(pSubString){
                    var key = pSubString.split(&#x27;:&#x27;)[0],
                        value = pSubString.substr( pSubString.indexOf(&#x27;:&#x27;)+1 );
                    if ( !!pSubString ) {
                        obj.responseHeaders[key] = value;
                    }
                });

            // attempt to convert text to JSON object
            if ( !!pOptions[&#x27;dataType&#x27;] &amp;&amp; pOptions[&#x27;dataType&#x27;].toLowerCase() === &#x27;json&#x27; ){
                try{
                    obj.data = JSON.parse( pObj.connection.responseText );
                } catch(e) {
                    console.warn( &#x27;expected JSON, could not parse: &#x27; + pObj.connection.responseText );
                }
            }

            return obj;
        }

        /** @private */
        function release(pReq) {
            dec( pReq );
            if (pReq.connection){
                pReq.connection = null;
            }
            pReq = null;
        }

        function inc( pReq ) {
            tb.status.loadCount( tb.status.loadCount() + 1 );
            loadlist.push( pReq );
            count++;
            readyState = &#x27;loading&#x27;;
        }

        function dec( pReq ) {
            tb.status.loadCount( tb.status.loadCount() - 1 );
            if ( loadlist.indexOf( pReq ) ){
                count--;
                loadlist.splice( loadlist.indexOf( pReq ) );
                if ( count === 0 ){
                    readyState = &#x27;complete&#x27;;
                }
            }
        }

        return function (pOptions) {
            var uid = &#x27;tb&#x27; + tb.getId(),
                xmlreq = getConnection(uid),
                method = (pOptions.method ? pOptions.method.toUpperCase() : false) || &#x27;GET&#x27;,
                url = pOptions.url,
                params = &#x27;&#x27;,
                successHandler = pOptions.success || tb.nop,
                errorHandler = pOptions.error || tb.nop,
                finalHandler = pOptions.finally || tb.nop,
                stateHandler = pOptions.statechange || tb.nop,
                isCachable = pOptions.cachable || true,
                headers = pOptions.headers = pOptions.headers || {},
                timeout = pOptions.timeout || false,
                isAsync = (typeof pOptions.async !== &#x27;undefined&#x27; &amp;&amp; pOptions.async === false) ? false : true,
                ct;

            inc();

            // adjust for JSON data
            if ( !!pOptions[&#x27;type&#x27;] &amp;&amp; pOptions[&#x27;type&#x27;].toLowerCase() === &#x27;json&#x27;  ){
                headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset=UTF-8&#x27;;
            }

            if (typeof pOptions.params !== &#x27;undefined&#x27;) {
                ct = ( headers &amp;&amp; headers[&#x27;Content-Type&#x27;]
                    ? headers[&#x27;Content-Type&#x27;]
                    : &#x27;application/x-www-form-urlencoded&#x27; );

                // parameter handling
                switch ( ct ){
                    case &#x27;application/json;charset=UTF-8&#x27;:

                        params = JSON.stringify( pOptions.params );
                        break;

                    default:

                        Object
                            .keys( pOptions.params )
                            .forEach(
                                function( pParam ){
                                    params += ((params.length &gt; 0 ? &#x27;&amp;&#x27; : &#x27;&#x27;) + pParam + &#x27;=&#x27; + pOptions.params[pParam]);
                                }
                            );

                        break;
                }

            }

            // proxy disable - cache busting
            if (isCachable === false) {
                url += (url.indexOf(&#x27;?&#x27;) &lt; 0 ? &#x27;?&#x27; : &#x27;&amp;&#x27;) + &#x27;tbUid=&#x27; + uid;
            }

            if (xmlreq) {
                var promise = new tb.Promise(function( resolve, reject ){
                    if ( ( method === &#x27;GET&#x27; || method === &#x27;DELETE&#x27; ) &amp;&amp; params !== &#x27;&#x27;) {
                        url = url + (url.indexOf(&#x27;?&#x27;) &lt; 0 ? &#x27;?&#x27; : &#x27;&amp;&#x27;) + params;
                    }
                    xmlreq.src = url;

                    xmlreq.connection.open(method, url, isAsync);

                    if (isAsync === true) {
                        xmlreq.poll = handleReadyState(xmlreq, resolve, stateHandler, reject, pOptions);
                    }

                    // set request headers
                    Object
                        .keys( headers )
                        .forEach(
                            function( pHeaderVar ){
                                if (pHeaderVar !== &#x27;Content-Type&#x27;) {
                                    xmlreq.connection.setRequestHeader(pHeaderVar, headers[pHeaderVar]);
                                }
                            }
                        );

                    // abort functionality
                    if (timeout) {
                        xmlreq.timeoutTimer = window.setTimeout(

                            (function (pT, pR) {
                                var f = typeof pT.cb === &#x27;function&#x27; ? pT.cb : false;
                                return function () {
                                    //if ( !myR &amp;&amp; myR.connection.status == 4 ) { return; }
                                    if (typeof f === &#x27;function&#x27;) {
                                        f( /*createResponseObject(myR)*/ );
                                    }
                                    pR.connection.abort();
                                    window.clearInterval(pR.poll);
                                };
                            })(timeout, xmlreq), timeout.ms);
                    }

                    xmlreq.abort = ( function(xmlreq) {
                        return function () {
                            window.clearInterval(xmlreq.poll);
                            if (xmlreq.connection){
                                xmlreq.connection.abort();
                            }
                            release(xmlreq);
                        };
                    })( xmlreq );

                    // send
                    if (method === &#x27;POST&#x27; || method === &#x27;PUT&#x27;) {
                        if (params !== &#x27;&#x27;) {
                            xmlreq.connection.setRequestHeader(&#x27;Content-Type&#x27;, ct);
                            xmlreq.connection.send(params);
                        }
                        else {
                            xmlreq.connection.send(null);
                        }
                    }
                    else {
                        xmlreq.connection.send(null);
                    }
                    // if sync request direct handler call
                    if (isAsync === false) {
                        tb.request.dec();
                        if (xmlreq.connection.status &gt;= 200 &amp;&amp; xmlreq.connection.status &lt; 300) {
                            resolve( createResponseObject( xmlreq, tb.extend( {}, pOptions ) ) );
                        }
                        else {
                            reject( createResponseObject( xmlreq, tb.extend( {}, pOptions ) ) );
                        }
                    }
                });

                promise
                    .then(function(pResult){
                        successHandler( pResult );
                    })
                    .catch(function(pResult){
                        errorHandler( pResult );
                    })
                    .finally(function(pResult){
                        finalHandler( pResult );
                    });

                return promise;
            }
            else {
                return false;
            }
        };

    })();
} else {
    // todo: implement module foreign request
}

/**
 @method tb.stop

 @param {boolean} pStopit - indicating whether to stop event handling

 @return {boolean} - true if event handling stopped, else false

 stops event handling

 */
tb.stop = (function(pStopIt){
    var stopIt = pStopIt;
    return function( pStopIt ){
        return (stopIt = ( !!pStopIt ? pStopIt : stopIt ) );
    };
})( false );



/**
 @class tb.CRUD
 @constructor

 @param {object} pConfig - config parameter, usually an object @todo param description

 @return {object} - the model instance

 tb.CRUD constructor
 - create and return a simple CRUD model a &quot;data&quot; observable

 @example

     // CRUD model
     that.model = new tb.CRUD({
        &#x27;read&#x27;: {
            url: &#x27;demoapp/configuration/mock/demoapp-configuration-templates.json&#x27;, // mock data
            method: &#x27;GET&#x27;,
            type: &#x27;json&#x27;,
            success: function( pResult ){
                that.model.data( JSON.parse( pResult.text ).data );
            },
            error: function( pResult ){
                console.log( &#x27;an error occured&#x27;, pResult );
            }
        }
     });

     // ... and later:

     // when template list data has been read, render
     that.model.data.observe( function modelDataChanged(){
        that.trigger( &#x27;render&#x27; );
     });

     // read data
     that.model.read({
        // parameters ...
     });

 @example

     // default config mixin -&gt; result will be in that.config
     // just for documentation purposes, will be done by the CRUD model itself

     tb.extend(
         that.config,
         {   // default settings, reference only
             &#x27;create&#x27;: {
                 url: &#x27;&#x27;,
                 method: &#x27;POST&#x27;,
                 success: function( pResult ){
                     that.data( pResult );
                 }
             },
             &#x27;read&#x27;: {
                 url: &#x27;&#x27;,
                 method: &#x27;GET&#x27;,
                 success: function( pResult ){
                     that.data( pResult );
                 }
             },
             &#x27;update&#x27;: {
                 url: &#x27;&#x27;,
                 method: &#x27;PUT&#x27;,
                 success: function( pResult ){
                     that.data( pResult );
                 }
             },
             &#x27;delete&#x27;: {
                 url: &#x27;&#x27;,
                 method: &#x27;DELETE&#x27;,
                 success: function( pResult ){
                     that.data( pResult );
                 }
             }
         },
         pConfig // params as given to the constructor 
     );

 */
if (typeof module === &#x27;undefined&#x27; ){ // will not work as a module

    tb.CRUD = function ( pConfig ) {
        var that = this;

        // result element
        that.data = tb.observable( {} );
        that.config = {};

        // default config mixin -&gt; result will be in that.config
        tb.extend(
            that.config,
            {   // default settings, reference only
                &#x27;create&#x27;: {
                    url: &#x27;&#x27;,
                    method: &#x27;POST&#x27;,
                    success: function( pResult ){
                        that.data( pResult );
                    }
                },
                &#x27;read&#x27;: {
                    url: &#x27;&#x27;,
                    method: &#x27;GET&#x27;,
                    success: function( pResult ){
                        that.data( pResult );
                    }
                },
                &#x27;update&#x27;: {
                    url: &#x27;&#x27;,
                    method: &#x27;PUT&#x27;,
                    success: function( pResult ){
                        that.data( pResult );
                    }
                },
                &#x27;delete&#x27;: {
                    url: &#x27;&#x27;,
                    method: &#x27;DELETE&#x27;,
                    success: function( pResult ){
                        that.data( pResult );
                    }
                }
            },
            pConfig
        );

    };

    tb.CRUD.prototype = (function(){
        // private

        // create get parameter string
        function makeGetParameterString( pParameterObject ){

            var result=&#x27;&#x27;;

            Object
                .keys( pParameterObject )
                .forEach(
                    function( key ) {
                        result += ( !!result ? &#x27;&amp;&#x27; : &#x27;&#x27; ) + key + &#x27;=&#x27; + pParameterObject[key];
                    }
                );

            return result;
        }

        return {

            /**
             @method create

             @param {object} [pParameters] - any combination of parameters

             .create() method

             */
            &#x27;create&#x27;: function( pParams ){
                var o = tb.extend( {}, this.config.create );

                pParams = pParams || {};

                if ( !o.url ){
                    console.error( &#x27;no create url given!&#x27;);
                    return;
                }

                tb.request(
                    tb.extend(
                        o,
                        { // if params given, use microparse to fill them in url
                            url: pParams ? tb.parse( this.config.create.url, pParams ) : this.config.create.url
                        },
                        {
                            params: pParams
                        }
                    )
                );

            },

            /**
             @method read

             @param {object} [pParameters] - any combination of parameters

             .read() method

             */
            &#x27;read&#x27;: function( pParams ){

                var o = tb.extend( {}, this.config.read );

                pParams = pParams || {};

                if ( !o.url ){
                    console.error( &#x27;no read url given!&#x27;);
                    return;
                }

                tb.request(
                    tb.extend(
                        o,
                        { // if params given, use microparse to fill them in url
                            url: pParams ? tb.parse( this.config.read.url, pParams ) : this.config.read.url
                        },
                        {
                            params: pParams
                        }
                    )
                );

            },

            /**
             @method update

             @param {object} [pParameters] - any combination of parameters

             .update() method

             */
            &#x27;update&#x27;: function( pParams ){
                var o = tb.extend( {}, this.config.update );

                pParams = pParams || {};

                if ( !o.url ){
                    console.error( &#x27;no update url given!&#x27;);
                    return;
                }

                tb.request(
                    tb.extend(
                        o,
                        { // if params given, use microparse to fill them in url
                            url: pParams ? tb.parse( this.config.update.url, pParams ) : this.config.update.url
                        },
                        {
                            params: pParams
                        }
                    )
                );

            },

            /**
             @method delete

             @param {object} [pParameters] - any combination of parameters

             .delete() method

             */
            &#x27;delete&#x27;: function( pParams ){
                var o = tb.extend( {}, this.config[&#x27;delete&#x27;] );

                pParams = pParams || {};

                if ( !o.url ){
                    console.error( &#x27;no delete url given!&#x27;);
                    return;
                }

                tb.request(
                    tb.extend(
                        o,
                        { // if params given, use microparse to fill them in url
                            url: pParams ? tb.parse( this.config.delete.url, pParams ) : this.config.delete.url
                        },
                        {
                            params: pParams
                        }
                    )
                );

            }

        };

    })();
}


class Tb extends tb{

    constructor( pConfig, pTarget ){

        super( pConfig, pTarget );

        var that = this,
            observable = Symbol(&#x27;observable&#x27;),
            onChange = Symbol(&#x27;onChange&#x27;);
        
        // make anonymous property
        that[observable] = tb.observable(false);

        // must be debounced for looped property changes like
        // ... tb.extend( store, $(&#x27;form&#x27;).values() );
        that[onChange] = tb.debounce(
            function(){
                this[observable]( tb.extend( {}, this ) );
            },
            0
        );

    }

}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
